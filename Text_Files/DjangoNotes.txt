app.py: this is a configuration file of the app itself.

tests.py: this file is used to write unit tests for the app.

In URLs.py: url(r'^$', views.home, name='home') checks for an empty path

start project.
start application.
create template dir & template files.
create static directory & corresponding files.
perform activities related to settings.py file.

sudo pip insall django
django-admin startproject my_project
django-admin 
Settings: Set your time zone TIME_ZONE
django.contrib.admin -- admin site
django.contrib.auth -- authentication system
django.contrib.contenttypes -- framework for content types.
django.contrib.sessions -- session framework
django.contrib.messages -- messaging framework
django.contrib.staticfiles -- framework to manage static files
django.db import models

python manage.py migrate
python manage.py runserver
python manage.py startapp app_name


python manage.py check -- will check if there's no problem in project without touching database.
python manage.py shell
	q = Question.objects.get(pk=1)
	q.choice_set.all()
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.all()
	Choice.objects.filter(question__pub_date__year=currentyear)
	Choice.objects.filter(choice_text__startswith="")

python manage.py createsuperuser

Where are the Django files:
	$ python -c "
	import sys
	sys.path = sys.path[1:]
	import django
	print(django.__path__)"

<PRIMARY KEY AND FOREIGN KEY MODELS>:
	class A():
		aa = '123'
		bb = models.ForeignKey(bb, null=True, blank=True)

	class B():
		id = '345'
		ff = 'abc'
		dd = 'def'
		ee = 'fgh'

	Now A has foreignKey defined and pointing to B.
	Now I want to fetch the data of class B by object of class A

	obj_A = A.objects.filter(aa='123')
	obj_A.bb.id
	obj_A.bb.dd
	obj_A.bb.ee

    Now I want to fetch data of Class A by class B.
    obj_B = B.objects.filter(id='345')        
    obj_B.A_set.all()[0].aa
    obj_B.A_set.all()[0].bb

<CLASS BASED VIEWS>:
    If the request is a POST, it will execute the post() method inside the view, if the request is a GET, it will execute the get() method inside the view.

from django.views import View

    class ContactView(View):
        def get(self, request):
            # Code block for GET request

        def post(self, request):
            # Code block for POST request

    urlpatterns = [
        url(r'contact/$', views.ContactView.as_view(), name='contact'),
        ]

<FUNCTION BASED VIEWS>:
    In function-based views, this logic is handled with if statements:
    def contact(request):
        if request.method == 'POST':
            # Code block for POST request
        else:
            # Code block for GET request (will also match PUT, HEAD, DELETE, etc) 

    urlpatterns = [
        url(r'contact/$', views.contact, name='contact'),
        ]

    # -*- coding: utf-8 -*-
    from __future__ import unicode_literals

    from django.db import models
    from django.contrib.auth.models import User

    # Create your models here.
    class Board(models.Model):
        name = models.CharField(max_length=30, unique=True)
        description = models.CharField(max_length=100)

        def __str__(self):
            return self.name        # will give self.name when accessed

    class Topic(models.Model):
        subject = models.CharField(max_length=255)
        last_updated = models.DateTimeField(auto_now_add=True)
        board = models.ForeignKey(Board, related_name='topics')
        starter = models.ForeignKey(User, related_name='topics')

    class Post(models.Model):
        message = models.TextField(max_length=4000)
        topic = models.ForeignKey(Topic, related_name='posts')
        created_at=models.DateTimeField(auto_now_add=True)
        updated_at = models.DateTimeField(null=True)
        created_by = models.ForeignKey(User, related_name='posts')
        updated_by = models.ForeignKey(User, null=True, related_name='+')

    >>> from apps.boards.models import Board
    >>> board = Board(name="Django", description="This is a board about Django")
    >>> board.save()
    >>> board.id
        1
    >>> board.name
        'Django'
    >>> board.description
        'This is a board about Django'
    >>> board.description = 'Django discussion board.'
    >>> board.save()

Every django model comes with a Model manager attribute, we can access it via python attribute objects.
It is mainly used to execute queries on the database: 
    >>> board = Board.objects.create(name="Python", description="General discussion")
    >>> board.id
        1
    >>> board.name
        "Python"

    >>> board = Board.objects.all()
    >>> board = Board.objects.get(id=2)


    Create an object without saving:            board = Board()
    Save an object (create or update)           board.save()
    Create and save an object in db             Board.objects.create(name='...', description='...')
    List all objects                            Board.objects.all()
    Get a single obj identified by a field      Board.objects.get(id=1)

    TEMPLATES = [
                    {
                    'BACKEND': 'django.template.backends.django.DjangoTemplates',
                    'DIRS': [os.path.join(BASE_DIR, 'awa/templates')],
                    'APP_DIRS': True,
                    'OPTIONS': {
                    'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                                         ],
                                },
                     },                                                                                 ]

    >>> from django.conf import settings
    >>> settings.BASE_DIR
        '/Users/vitorfs/Development/myproject'
    >>> import os
    >>> os.path.join(settings.BASE_DIR, 'templates')
        '/path/till/the/templates/'

    And then write a view which will render the response in HTML format

    apps/boards/test.py
    from django.core.urlresolvers import reverse
    from django.test import TestCase

    class HomeTests(TestCase):
        def test_home_view_status_code(self):
            url = reverse('home')
            response = self.client.get(url)
            self.assertEquals(response.status_code, 200)

    $ python manage.py test
    $ python manage.py test --verbosity=2 (To see more verbosity)

    create a 'static' directory inside the project and all the css/js content will be coming over there.
    project/settings.py
    STATIC_URL = '/static/'

    STATICFILES_DIRS = [
        os.path.join(BASE_DIR, 'awa/static'),
            ]

    $ python manage.py createsuperuser
    
    apps/boards/admin.py
    # -*- coding: utf-8 -*-
    from __future__ import unicode_literals

    from django.contrib import admin
    from models import Board

    admin.site.register(Board)

This is the anatomy of the url function:
    def url(regex, view, kwargs=None, name=None)

regex: A regular expression for matching URL patterns in strings. Note that these regular expressions do not search GET or POST parameters. In a request to http://127.0.0.1:8000/boards/?page=2 only /boards/ will be processed.

urlpatterns = [
    url(r'^$', home, name='home'),
        url(r'(?P<pk>\d+)/$', board_topics, name='board_topics'),
            ]

view: A view function used to process the user request for a matched URL

The regex \d+ will match an integer of arbitrary size. This integer will be used to retrieve the Board from the database. Now observe that we wrote the regex as (?P<pk>\d+), this is telling Django to capture the value into a keyword argument named pk.        
        url(r'(?P<pk>\d+)/$', board_topics, name='board_topics'),

Here's how we write a view function for it:

    def board_topics(request, pk):
        # do something...

Because, we use r'^boards/(?P<pk>\d+)/$' regex, the keyword argument in view must be named pk,

If we wanted to use any name, we could do it like this:
    r'^boards/(\d+)/$'


$ django-admin startproject practice_project
$ python manage.py makemigrations
$ python manage.py migrate
$ python manage.py startapp testApp
Add the testApp to INSTALLED_APPS dictionary

views.py
1. function based views
2. class based views

Create an application level URLs.py
Calling application level URLs from project level urls.py file

* Setting up templates for the project
--------------------------------------------------------------------------
    Create templates named folder within your project's Base directory
    Create testApp named folder inside BASE_DIR/templates folder (will hold testApp related templates)
    Add templates folder to settings.py file so Django is aware of our templates.

    DIRS key needs to be popullated with our templates folder (os.path.join(BASE_DIR,  'templates'))
        TEMPLATES = [
            {
                'BACKEND': 'django.template.backends.django.DjangoTemplates',
                'DIRS': [os.path.join(BASE_DIR,  'templates')],
                'APP_DIRS': True,
                'OPTIONS': {
                    'context_processors': [
                        'django.template.context_processors.debug',
                        'django.template.context_processors.request',
                        'django.contrib.auth.context_processors.auth',
                        'django.contrib.messages.context_processors.messages',
                    ],
                },
            },
        ]

* Setting up static content for the project
--------------------------------------------------------------------------
    Inside,  main project folder, create a folder named static
    WIthin static folder --> images/css/js folder will be created as well

    We  have added TEMPLATE_DIR inside settings.py file, In the same manner we'll add static path settings.

TEMPLATE_DIR = os.path.join(Path(__file__).resolve().parent, 'templates')
STATIC_DIR = os.path.join(Path(__file__).resolve().parent, 'static')

    STATIC_URL = '/static/'
    STATICFILES_DIRS = [STATIC_DIR, ]

To include static files into templates
--------------------------------------
    {% load static %} --> All static files will be available to our html template.

To include css files into template
--------------------------------------
    <link rel='stylesheet' href='demo.css'>                     # general manner
    <link rel="stylesheet" href="{% static 'css/demo.css' %}">  # Django manner

{{ msg }} --> template tag to insert simple data
{%  %} --> 

To insert images:
--------------------------------------
    <img src="{% static 'images/jenkins.png' %}">

Navigating to different page:
--------------------------------------
    <a href="/staticView">Click here for image</a>

Admin Panel:

When I want to display some columns in admin panel
--------------------------------------------------
    class StudentAdmin(admin.ModelAdmin):
        list_display = ['name', 'marks']

    admin.site.register(Student, StudentAdmin)

Django forms:
--------------------------------------------------
1. Validations are very easy with forms
2. Creation of forms, based on models are very easy
3. HTML form widgets
    
    Inside models.py file - 
    class Student(models.Model):
        name = models.CharField(max_length=100)
        marks = models.IntegerField()

    Inside forms.py file - 
    from django import forms
    class StudentForm(forms.Form):
        name = forms.CharField()
        marks = forms.IntegerField()

    Inside views.py - 
    form = forms.StudentForm()

    - Send it to template file
    context_dict = {'form': form}
    return render(request, 'testApp/student_regitration.html', context=context_dict)

    Inside template.html - 
    <body>
        {{ form }}
    </body>

With this method, a form will be generated when we'll navigate to respective URL
    <body>
        {{ form.as_p }}
    </body>

    This will make all the text fields display vertically and not horizontally.

    Form is now available and we may need to submit the data filled in text boxes:

    <body>
    <form method="POST">
        {{ form.as_p }}
        {% csrf_token %}                # this will be changing at every request and django will take care of it.
                                        # In our form, django will add one hidden form field
    <input type="submit" value="Register">
    </form>
    </body>    

We didn't specify any action (such as when button is clicked then where the request will go, so it'll automatically
be going to the same views function), which we can capture from request.POST and will use form to save the data

    def thankyou_view(request):
        return render(request, 'testApp/thankyou.html')

    def studentFeedback(request):
        form = StudentFeedbackForm()
        if request.method == "POST":
            form = StudentFeedbackForm(request.POST)
            if form.is_valid():
                print("Form validation success, printing feedback information")
                print(form.cleaned_data)
                return thankyou_view(request)
        return render(request, 'testApp/student_feedback.html', {'form': form})

We can now apply the restrictions/validation on data such that:
    Email should be in proper format
    Age cannot greater than 100 years like that

Inside forms.py file, there are 2 types of validations available:
    1. Explicit validation by developer using clean methods
    2. Implicit validation by Django.

    I want to put a validation that name should always be atleast 4 characters then, we'll be writing clean method
    for name attribute such as: def clean_name(self)

    from django import forms
    class StudentForm(forms.Form):
        name = forms.CharField()
        marks = forms.IntegerField()
        feedback = forms.CharField(widget=forms.Textarea)   # widget=forms.Textarea makes feedback as TextArea

        def clean_name(self):
            inputname = self.cleaned_data['name']
            if len(inputname) < 4:
                raise forms.validationError('Name should atleast be 4 characters')
            return inputname

    In the same manner, we can write explicit clean method for all the attributes

We can also use Implicit validations, say --> feedback can max be of 40 characters

        from django.core import validators
        from django import forms
        class StudentForm(forms.Form):
            name = forms.CharField()
            marks = forms.IntegerField()
            forms.CharField(widget=forms.Textarea, validators=[validators.MaxLengthValidator(40), 
        validators.MinLengthValidator(10)])

We can also write our own validators too. 

        from django.core import validators
        from django import forms

        def starts_with_t(value):
            if value[0] != 't'
                raise forms.validationError('Name should start with t')

        class StudentForm(forms.Form):
            name = forms.CharField(validators=[starts_with_t])
            marks = forms.IntegerField()
            forms.CharField(widget=forms.Textarea)

Now, rather than writing various clean method for each & every field, we can write a single clean method for the 
whole form.

        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField()
            password  = 
            feedback = forms.CharField(widget=forms.Textarea)
            
            def clean(self):
                cleaned_data = super(StudentFeedbackForm, self).clean()
                inputname = cleaned_data['name']
                if len(inputname) < 4:
                    raise forms.ValidationError('Name should atleast be 4 characters')

                inputfeedback = cleaned_data['feedback']
                if 'feedback' not in inputfeedback:
                    raise forms.ValidationError('Feedback keyword is expected')

                return cleaned_data

We can also compare 2 input fields within the clean method as below:

        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField()
            password  = forms.CharField(widget=forms.PasswordInput)
            rpassword = forms.CharField(widget=forms.PasswordInput)
            feedback = forms.CharField(widget=forms.Textarea)

            def clean(self):
                inputpwd = cleaned_data['password']
                inputrpwd = cleaned_data['rpassword']
                if inputpwd != inputrpwd:
                    raise forms.ValidationError('Passwords does not match!')

                return cleaned_data

We're seeing default labels on HTML page, If we want to use our own label, then use:

        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField(label='Email Account')
            password  = forms.CharField(label='Password', widget=forms.PasswordInput)
            rpassword = forms.CharField(label='Password (again)', widget=forms.PasswordInput)
            feedback = forms.CharField()

    and we'll see Password & Password (again) on html page.

If request is coming from BOT, then form should not be submitted.
        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField(label='Email Account')
            password  = forms.CharField(label='Password', widget=forms.PasswordInput)
            rpassword = forms.CharField(label='Password (again)', widget=forms.PasswordInput)
            feedback = forms.CharField(widget=forms.Textarea, validators=[validators.MaxLengthValidator(40), 
                validators.MinLengthValidator(10)])
            bot_handler = forms.CharField(required=False, widget=forms.HiddenInput)

            def clean(self):
                cleaned_data = super(StudentFeedbackForm, self).clean()s
                inputbot = cleaned_data['bot_handler']
                if len(inputbot) > 0:
                    raise forms.ValidationError('Bot send this request')

    Because we have introduced a hidden field, it means it'll not be visible to end-user and user will not be
    filling it and we won't receive it in request parameters. If bot tries to submit the form, it'll fill this field
    and if we receive this hidden field in request, then we can know that their is some suspicious activity which 
    submit this form.

    This will not proceed the request further and will return with form validation for bot_handler field.
    To test: Go to html form, inspect, go to hidden field, add attribute, put some value and submit - it'll return

Model Forms:
----------------------------------------------------------
We can implement a form class and can mention - On which model, this form class is based of.

        class RegisterForm(forms.ModelForm):
            # fields declaration

            class Meta:
                model = Student
                fields = '__all__'      # fields = ('field1', 'field2', 'field3')

If we require fields validation, then we need to use fields_declaration else not.

fields = '__all__'
fields = ('field1', 'field2', 'field3')
exclude = ['field4', 'field5']

views.py:
    if request.method == "POST":
        form = RegisterForm(request.POST)
        if form.is_valid():
            form.save(commit=True)

forms.py
-----------------------------------
        class StudentForm(forms.ModelForm):
            class Meta:
                model = Student
                fields = '__all__'

register.html
-----------------------------------
        <body>
            <div class="container" align="center">
            <form method="POST">
            <h1>This is Student Registration Portal using Model form</h1><br>
            {{ form.as_p }}
            {% csrf_token %}
            <input type="submit" class="btn btn-primary btn-lg" value="Register">
        </form></div></body>

views.py
----------------------------------
        def student_view(request):
            form = StudentForm()
            if request.method == "POST":
                form = StudentForm(request.POST)
                if form.is_valid():
                    form.save(commit=True)
            return render(request, 'testApp/register.html', {'form': form})

Create a Project where we add the movies & list the added movies.

Advanced Templates:
---------------------------------
    Template Inheritance
    Template Filters

        {% extends 'testApp/base.html' %}
            {% block child_block %}
                Child HTML specific code
            {% endblock %}

Write a base html page such as:
    base.html
        {% load static %}
        <body>
        // some html code, maybe header/footer/menu bar
        {% block body_block %}
        // will be empty in base html to use in child html pages
        {% endblock %}
        </body>

    child.html
        <!DOCTYPE html>
        {% extends 'testApp/news_portal/base.html' %}
        {% block body_block %}
        <h1>Welcome to News Portal</h1>
        {% endblock %}

Inside Views.py:
        def display_view(request):
            name = "mangesh"
            subject = "Python"
            my_dict = {'name': name,'subject': subject}
            return render(request, 'testApp/display.html', context_dict=my_dict)

Inside display.html file:
    Name: {{ name|upper }} --> Mangesh
    Subject: {{ subject }}

    There are builtin filters that we can use in html files on our data received from views.py
We can also create our own Django filters using
- We need to create templatetags folder in our application folder
- __init__.py file
- cust_filters.py file

After setting up the files, we can then write some code in cust_filters.py file

        from django import template
        register = template.Library()

        def truncate5(value):
            result = value[0:5]
            return result

        register.filter('truncate5', truncate5)

Now, truncate5 function is registered as a filter and can be applied to template as:
    We need to load this filter file inside our template and use the filter on value

    {% load cust_filters %}
    {{ movie.moviename| truncate5 }}

Here, we have hardcoded the value as 5, we can also have a dynamic value on basis of which filter will be applied.

        from django import template
        register = template.Library()

        def truncateN(value, n):
            result = value[0:n]
            return result

        register.filter('truncateN', truncateN)

        {{ movie.actor | truncateN:3 }}

Syntax: {{ value | filtername:arguments }}  

register.filter('truncateN', truncateN) can further be optimised as: 
        
        @register.filter(name='truncateN')
        def truncateN(value, n):
            result = value[0:n]
            return result

        {{ movie.actor | truncateN:3 }}
        register.filter('truncateN', truncateN)


Session Management:
------------------------------------------
Requests are stateless, how do we make sure that server remembers the last request.
By Cookies: When there's a first request,  server will return the response as Response + Cookies. The same cookie 
will be send in every consecutive request by client, so that server can identify the client. Issues:
    1. Network (not suitable for huge chunk of data)
    2. Security (what if virus gets attached to cookie)
    3. Cookies are plain text

This is how we set cookie in response
    response.set_cookie(cookiename, cookievalue)

    request.COOKIES.get('cookiename', 'default_value')

Example to count page hits on basis of cookies:
    We're setting one cookie named count and will try to fetch count named cookie at every request, We'll set it's
    value incremented by 1 and will display the count.

        def count_view(request):
            count = int(request.COOKIES.get('count', 0))
            updated_count = count + 1
            response = render(request, 'testApp/session_manage/count_view.html', context={'count': updated_count})
            response.set_cookie('count', updated_count)
            return response

Temporary cookies & persistent cookies:
------------------------------------------
If we're not setting max_age, then they're temporary cookies and will be vanished as soon as browser is closed,
These are saved in browser's cache.

response.set_cookie('cookie', updated_count, max_age=180)

# it'll persist for 10 seconds since it was hit last time even if the browser is closed.

Scenario: If we keep on submitting the data to a page and then navigate to other page, and On other page we again
submit the data and then navigate to another page and so on...Will our server be able to remember the data that we
submitted in first/second/.. pages ?  
    We will create 3 pages -
        Save Name, Save Age, Save Qualification

        views.py
        def save_name(request):
            return render(request, 'testApp/session_manage/save_name.html')

        def save_age(request):
            return render(request, 'testApp/session_manage/save_age.html')

        def save_qualification(request):
            return render(request, 'testApp/session_manage/save_qualification.html')

        <body>
            <h1>Enter your Name</h1>
            <form action='/save_age'>
            Enter Name: <input type="text" name="name" value=""><br><br>
            <input type="submit" name="" value="Submit Name">
            </form>
        </body>

        <body>
            <h1>Enter your Age (In years)</h1>
            <form action='/save_qualification'>
            Enter Age: <input type="text" name="age" value=""><br><br>
            <input type="submit" name="" value="Submit Age">
            </form> 
        </body>

        <body>
            <h1>Enter your maximum Qualification</h1>
            <form action='/display_results'>
            Enter Degree: <input type="text" name="qualification" value=""><br><br>
            <input type="submit" name="" value="Submit Qualification">
            </form> 
        </body>

Job of save_age view:
----------------------------
1. Read name entered by end-user in previous html page 
2. Save that name for the future use inside cookie
3. Display age form after submitting age

        def save_name(request):
            return render(request, 'testApp/session_manage/save_name.html')

        def save_age(request):
            name = request.GET['name']
            response = render(request, 'testApp/session_manage/save_age.html')
            response.set_cookie('name', name)
            return response

        def save_qualification(request):
            age = request.GET['age']
            # <input type="text" name="age" value=""> is the one from where we set name as age and fetch
            # in request.GET params

            response = render(request, 'testApp/session_manage/save_qualification.html')
            response.set_cookie('age', age)
            return response

        def display_results(request):
            name = request.COOKIES.get('name')
            age = request.COOKIES.get('age')
            qualification = request.GET['qualification']
            context_dict = {'name': name, 'age': age, 'qualification': qualification}
            return render(request, 'testApp/session_manage/display_results.html', context=context_dict)

Django Session Framework: 
    Cookies Example: RMP Doctor
    Session Example: Bank Locker -- Client is only responsible to maintain the token/session-ID

    Client requests for some data, server returns response + cookie, and Server doesn't have to maintain anything.
    Client again sends a request but request params contain: request+cookie this time.
    Here, Client is responsible to maintain all the cookie data

    Client requests for some data, if server wants to remember any information for future purpose, it creates a 
    session object and put all information in this session object and returns response + session_id.
    Client again sends a request but request params contain: reqeust+session_id this time.
    Here, Client is responsible to maintain only the session_id

        def page_count_view(request):
            count = request.session.get('count', 0)
            updated_count = count + 1
            print(request.session.get_expiry_age())
            print(request.session.get_expiry_date())
            response = render(request, 'testApp/session_manage/count_view.html', context={'count': updated_count})
            request.session['count'] = updated_count
            return response

We now want to replicate the same example, as we did with cookies. Enter one information, then other and then finally
display the results:, We will fecth the values from previous page, and will set them to session.
        def NameView(request):
            form = NameForm()
            return render(request, 'testApp/session_manage/save_name_form.html', {'form': form})

        def AgeView(request):
            name = request.GET['name']
            request.session['name'] = name
            form = AgeForm()
            return render(request, 'testApp/session_manage/save_age_form.html', {'form': form})

        def QualificationView(request):
            age = request.GET['age']
            request.session['age'] = age
            form = QualificationForm()
            return render(request, 'testApp/session_manage/save_qualification_form.html', {'form': form})

        def ResultView(request):
            qualification = request.GET['qualification']
            request.session['qualification'] = qualification
            return render(request, 'testApp/session_manage/session_form_result.html')

        On final result HTML page:
        <body>
            <h1>Thanks for providing information</h1>
                <ul>
                    {% for key, value in request.session.items %}
                    <li>{{ key|upper }}: {{ value|title }}</li>
                    {% endfor %}
                </ul>
        </body>

Adding keys & values into Session
        def add_item_view(request):
            form = AddItemForm()
            if request.method == "POST":
                name = request.POST['name']
                quantity = request.POST['quantity']
                request.session[name] = quantity
            return render(request, 'testApp/session_manage/session_additem.html', {'form': form})

            request.session.set_expiry(120)

    If we're not performing any operation on session for specified amount of time (max inactive internal), then session will be expired automatically.

    get_expiry_date()
    get_expiry_age()

        def session_info_view(request):
            session = request.session
            age = session.get_expiry_age()
            date =  session.get_expiry_date()

Deleting session data:
    del request.session[session_key]

    for key in request.session.keys()
        del request.session[key]

User Authentication:
----------------------------
User signup
We have to read data entered by enduser and store permanently

django.contrib.auth in INSTALLED_APPS helps us to achieve the authentication. user table is required.

We can create an exam portal which has various tabs such as:
    JavaExams, PythonExams, AptitudeExams and these will be opened as soon as User is signed up & logged in.

        base.html
        <body>
            <nav class="navbar navbar-default navbar-inverse">
                <div class="container">
                    <div class="navbar-header">
                        <a class="navbar-brand" href="/exam_portal_home">Exam Portal</a>
                    </div>
                    <ul class="nav navbar-nav">
                        <li><a href="/java_exams">Java Exams</a></li>
                        <li><a href="/python_exams">Python Exams</a></li>
                        <li><a href="/aptitude_exams">Aptitude Exams</a></li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li><a href="#">Sign Up</a></li>
                        <li><a href="#">Login</a></li>
                        <li><a href="#">Logout</a></li>
                    </ul>
                </div>
            </nav>
                {% block body_block %}
                <!-- Child  HTML will use the code from here -->
                {% endblock %}
          </body>

          pythonexams.html
          <!DOCTYPE html>
            {% extends 'testApp/auth_templates/base.html' %}
            {% block body_block %}
                <div class="jumbotron">
                    <div class="container" align="center">
                        <h1>Welcome to Python Exams</h1>
                    </div>
                </div>
            {% endblock %}

    from django.contrib.auth.decorators import login_required

    @login_required
    def java_exams_view(request):
        return render(request, 'testApp/auth_templates/javaexams.html')

    If user is authenticated, page will be shown else user will be thrown to login page 
    http://localhost:8000/accounts/login/?next=/java_exams

    As acccounts & auth pages are not configured yet, So we'll have to configure this is in our URLS.py file

            urlpatterns = [
                            path('admin/', admin.site.urls),
                            path('accounts/', include('django.contrib.auth.urls')),
                            path('', include('testApp.urls')),
                        ]

Now, this will rediret to login page, but it doesn't contain the template for login so we need to include the 
templates for accounts application as well.
    Create a folder named registration inside templates folder and login.html inside this html should contain:

            <!DOCTYPE html>
            {% extends 'testApp/auth_templates/base.html' %}
            {% block body_block %}
            <h1>Login to write exams</h1>
            <form method="POST">
                {{ form.as_p }}
                {% csrf_token %}
                <input type="submit" name="" value="Login">
            </form>
            {% endblock %}

    and we'll have a login form which is provided by auth module.

Now, as soon as we click on pages for JavaExams, it will ask to login and once we're logged in, we will be navigated
to JavaExams page. Now if we just directly click on login button, then by default - it'll go to accounts/profile page
which doesn't exist, So we need to tell where django should land when login happens.

        LOGIN_REDIRECT_URL = '/'

In the same manner,  after logging out:
        LOGOUT_REDIRECT_URL = '/Some/Logout/Information/Page'

So, it'll logout from portal and will navigate the page to '/Some/Logout/Information/Page' and it's content will be loaded to portal.

For Sign-Up, we can use Users model to get all the input text fields and then submit this form on registration.

            signup.html
            <form method="POST">
                {{ form.as_p }}
                {% csrf_token %}
                <input type="submit" class="btn btn-primary btn-lg" name="" value="Register now!">
            </form>

            forms.py
            class SignUpForm(forms.ModelForm):
                class Meta:
                    model = User
                    fields = ['username',  'password', 'email', 'first_name', 'last_name']

            views.py
            def SignupView(request):
                form = SignUpForm()
                if request.method == "POST":
                    form = SignUpForm(request.POST)
                    user = form.save()
                    user.set_password(user.password)
                    user.save()
                    # return render(request, 'registration/registration_successful.html', {'form': form})
                    return HttpResponseRedirect('/accounts/login')
                return render(request, 'registration/signup.html', {'form': form})

PASSWORD_HASHERS are explained in 78 Django

We can now want to update/delete the data that we're displaying on web page

            movies_list.html
            {% for movie in movies %}
              <tr>
                <td>{{ movie.rdate }}</td>
                <td>{{ movie.moviename| truncate5 }}</td>
                <td>{{ movie.actor | truncateN:10 }}</td>
                <td>
                    <a href="/movie_update/{{ movie.id }}">Update</a>
                    <a href="/movie_delete/{{ movie.id }}">Delete</a></td>
              </tr>
            {% endfor %}

            urls.py
            url(r'^movie_delete/(?P<id>\d+)/$',  views.movie_delete),

            views.py
            def movie_delete(request, id):
                movie = Movie.objects.get(id=id)
                movie.delete()
                return redirect('/movie_list')


When we want to update the record, then it'd go like this:
            urls.py
            url(r'^movie_update/(?P<id>\d+)/$',  views.movie_update),

            views.py
            def movie_update(request, id):
                movie = Movie.objects.get(id=id)
                if request.method=="POST":
                    form = MovieForm(request.POST, instance=movie)

                    # here, we've sent instance along with request.POST, if we don't send this then it'll create
                    # a new duplicate record rather than updating it.
                    if form.is_valid():
                        form.save(commit=True)
                    return redirect('/movie_list')
                return render(request, 'testApp/movie_update.html', {'movie': movie})

            movie_update.html
                <form method="POST">
                    {% csrf_token %}
                        Release Date: <input type="text" name="rdate" value="{{ movie.rdate }}">
                        Movie Name: <input type="text" name="moviename" value="{{ movie.moviename }}">
                        Movie Actor: <input type="text" name="actor" value="{{ movie.actor }}">
                        Movie Actress: <input type="text" name="actress" value="{{ movie.actress }}">
                        Movie Rating: <input type="text" name="rating" value="{{ movie.rating }}">
                    <input type="submit" name="" value="Update Record">
                </form>

Class Based Views:
    When we have simple operations such - Listing/View/DetailedView/Update/Delete/Create - then we can use
    already implemented views which are class based views and function based views gets executed behind the 
    scenes.

    So, If we require to List the data from a single Model, we can use class based views. But when we need to
    create the data from many table, do some manipulations then we can go for function based views.

    Class based views automatically identifies if request is GET/POST and then respective method is called
    def get(self, request) or def post(self, request)
        Example: 1
            urls.py
            url(r'^c_helloword',  cbf_views.HelloWorldView.as_view()),

            views.py
            from django.views.generic import View, TemplateView

            class HelloWorldView(View):
                def get(self, request):
                    return HttpResponse('<h1>This is from class Based views</h1>')

        Example: 2
        # It will render whatever the template is mentioned in 'template_name' variable
            views.py
            class HelloWorldTemplateView(TemplateView):
                template_name = "testApp/cbf_templates/results.html"

        Example: 3
        # If I wish to send some data to HTML page in above example, then We will write get_context_data which
        will return context_dict and this context_dict will be rendered on said HTML page.

        views.py
        class HelloWorldTemplateContext(TemplateView):
            template_name = "testApp/cbf_templates/info.html"

            def get_context_data(self, **kwargs):
                context = super().get_context_data(**kwargs)
                context['name'] = "Rahul"
                context['subject'] = "Python"
                return context

        Now, whatever we return in this get_context_data, the same can be used in template.

        info.html
            <body>
                <h1>Student Information</h1>
                <h3>Name: {{ name }}</h3>
                <h3>Subject: {{ subject }}</h3>
            </body>


Normal CBV:
------------------
View
TemplateView

Model Related CBV:
-------------------
    ListView
    DetailView
    CreateView
    DeleteView
    UpdateView

        views.py
        class MovieListView(ListView):
            model = Movie
            # default template will be <model_name>_list.html, In our case: movie_list.html
            # default context object will be movie_list


        movie_list.html <Inside Template Directory>
        <!DOCTYPE html>
        {% extends 'testApp/cbf_templates/base.html' %}
        {% block body_block %}
            <h1>
                Movies Information
            </h1>
            {% for movie in movie_list %}
                <ul><li class="list-group-item">Movie Name: {{ movie.moviename }}</li>
                    <li class="list-group-item">Movie Actor: {{ movie.actor }}</li></ul>
            {% endfor %}
        {% endblock %}

We can also change the name of default template name & of default context dictionary
        class MovieListView(ListView):
            model = Movie
            template_name = 'testApp/movies.html'
            context_object_name = 'list_of_books'

DetailedView:
        views.py
        class MovieDetailView(DetailView):
            model = Movie
            # default template will be movie_detail.html
            # default context object will be movie or object

        movie_detail.html
        {% extends 'testApp/cbf_templates/base.html' %}
        {% block body_block %}
            <h1>{{ movie.moviename }} Information</h1>
                <ul><li class="list-group-item">Movie Name: {{ movie.moviename }}</li>
                    <li class="list-group-item">Movie Actor: {{ movie.actor }}</li>
                    <li class="list-group-item">Release Date : {{ movie.rdate }}</li>
                </ul>
        {% endblock %}

        urls.py
        url(r'^c_movieDetail/(?P<pk>\d+)/$',  cbf_views.MovieDetailView.as_view()),

        movie_list.html
        {% for movie in movie_list %}
        <ul>
            <li class="list-group-item">
                Movie Name:<a href="/c_movieDetail/{{ movie.id }}"> {{ movie.moviename }}</a>
            </li>
        </ul>
        {% endfor %}