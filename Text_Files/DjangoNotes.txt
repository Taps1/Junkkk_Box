app.py: this is a configuration file of the app itself.

tests.py: this file is used to write unit tests for the app.

In URLs.py: url(r'^$', views.home, name='home') checks for an empty path

start project.
start application.
create template dir & template files.
create static directory & corresponding files.
perform activities related to settings.py file.

sudo pip insall django
django-admin startproject my_project
django-admin 
Settings: Set your time zone TIME_ZONE
django.contrib.admin -- admin site
django.contrib.auth -- authentication system
django.contrib.contenttypes -- framework for content types.
django.contrib.sessions -- session framework
django.contrib.messages -- messaging framework
django.contrib.staticfiles -- framework to manage static files
django.db import models

python manage.py migrate
python manage.py runserver
python manage.py startapp app_name


python manage.py check -- will check if there's no problem in project without touching database.
python manage.py shell
	q = Question.objects.get(pk=1)
	q.choice_set.all()
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.all()
	Choice.objects.filter(question__pub_date__year=currentyear)
	Choice.objects.filter(choice_text__startswith="")

python manage.py createsuperuser

Where are the Django files:
	$ python -c "
	import sys
	sys.path = sys.path[1:]
	import django
	print(django.__path__)"

<PRIMARY KEY AND FOREIGN KEY MODELS>:
	class A():
		aa = '123'
		bb = models.ForeignKey(bb, null=True, blank=True)

	class B():
		id = '345'
		ff = 'abc'
		dd = 'def'
		ee = 'fgh'

	Now A has foreignKey defined and pointing to B.
	Now I want to fetch the data of class B by object of class A

	obj_A = A.objects.filter(aa='123')
	obj_A.bb.id
	obj_A.bb.dd
	obj_A.bb.ee

    Now I want to fetch data of Class A by class B.
    obj_B = B.objects.filter(id='345')        
    obj_B.A_set.all()[0].aa
    obj_B.A_set.all()[0].bb

<CLASS BASED VIEWS>:
    If the request is a POST, it will execute the post() method inside the view, if the request is a GET, it will execute the get() method inside the view.

from django.views import View

    class ContactView(View):
        def get(self, request):
            # Code block for GET request

        def post(self, request):
            # Code block for POST request

    urlpatterns = [
        url(r'contact/$', views.ContactView.as_view(), name='contact'),
        ]

<FUNCTION BASED VIEWS>:
    In function-based views, this logic is handled with if statements:
    def contact(request):
        if request.method == 'POST':
            # Code block for POST request
        else:
            # Code block for GET request (will also match PUT, HEAD, DELETE, etc) 

    urlpatterns = [
        url(r'contact/$', views.contact, name='contact'),
        ]

    # -*- coding: utf-8 -*-
    from __future__ import unicode_literals

    from django.db import models
    from django.contrib.auth.models import User

    # Create your models here.
    class Board(models.Model):
        name = models.CharField(max_length=30, unique=True)
        description = models.CharField(max_length=100)

        def __str__(self):
            return self.name        # will give self.name when accessed

    class Topic(models.Model):
        subject = models.CharField(max_length=255)
        last_updated = models.DateTimeField(auto_now_add=True)
        board = models.ForeignKey(Board, related_name='topics')
        starter = models.ForeignKey(User, related_name='topics')

    class Post(models.Model):
        message = models.TextField(max_length=4000)
        topic = models.ForeignKey(Topic, related_name='posts')
        created_at=models.DateTimeField(auto_now_add=True)
        updated_at = models.DateTimeField(null=True)
        created_by = models.ForeignKey(User, related_name='posts')
        updated_by = models.ForeignKey(User, null=True, related_name='+')

    >>> from apps.boards.models import Board
    >>> board = Board(name="Django", description="This is a board about Django")
    >>> board.save()
    >>> board.id
        1
    >>> board.name
        'Django'
    >>> board.description
        'This is a board about Django'
    >>> board.description = 'Django discussion board.'
    >>> board.save()

Every django model comes with a Model manager attribute, we can access it via python attribute objects.
It is mainly used to execute queries on the database: 
    >>> board = Board.objects.create(name="Python", description="General discussion")
    >>> board.id
        1
    >>> board.name
        "Python"

    >>> board = Board.objects.all()
    >>> board = Board.objects.get(id=2)


    Create an object without saving:            board = Board()
    Save an object (create or update)           board.save()
    Create and save an object in db             Board.objects.create(name='...', description='...')
    List all objects                            Board.objects.all()
    Get a single obj identified by a field      Board.objects.get(id=1)

    TEMPLATES = [
                    {
                    'BACKEND': 'django.template.backends.django.DjangoTemplates',
                    'DIRS': [os.path.join(BASE_DIR, 'awa/templates')],
                    'APP_DIRS': True,
                    'OPTIONS': {
                    'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                                         ],
                                },
                     },                                                                                 ]

    >>> from django.conf import settings
    >>> settings.BASE_DIR
        '/Users/vitorfs/Development/myproject'
    >>> import os
    >>> os.path.join(settings.BASE_DIR, 'templates')
        '/path/till/the/templates/'

    And then write a view which will render the response in HTML format

    apps/boards/test.py
    from django.core.urlresolvers import reverse
    from django.test import TestCase

    class HomeTests(TestCase):
        def test_home_view_status_code(self):
            url = reverse('home')
            response = self.client.get(url)
            self.assertEquals(response.status_code, 200)

    $ python manage.py test
    $ python manage.py test --verbosity=2 (To see more verbosity)

    create a 'static' directory inside the project and all the css/js content will be coming over there.
    project/settings.py
    STATIC_URL = '/static/'

    STATICFILES_DIRS = [
        os.path.join(BASE_DIR, 'awa/static'),
            ]

    $ python manage.py createsuperuser
    
    apps/boards/admin.py
    # -*- coding: utf-8 -*-
    from __future__ import unicode_literals

    from django.contrib import admin
    from models import Board

    admin.site.register(Board)

This is the anatomy of the url function:
    def url(regex, view, kwargs=None, name=None)

regex: A regular expression for matching URL patterns in strings. Note that these regular expressions do not search GET or POST parameters. In a request to http://127.0.0.1:8000/boards/?page=2 only /boards/ will be processed.

urlpatterns = [
    url(r'^$', home, name='home'),
        url(r'(?P<pk>\d+)/$', board_topics, name='board_topics'),
            ]

view: A view function used to process the user request for a matched URL

The regex \d+ will match an integer of arbitrary size. This integer will be used to retrieve the Board from the database. Now observe that we wrote the regex as (?P<pk>\d+), this is telling Django to capture the value into a keyword argument named pk.        
        url(r'(?P<pk>\d+)/$', board_topics, name='board_topics'),

Here's how we write a view function for it:

    def board_topics(request, pk):
        # do something...

Because, we use r'^boards/(?P<pk>\d+)/$' regex, the keyword argument in view must be named pk,

If we wanted to use any name, we could do it like this:
    r'^boards/(\d+)/$'


$ django-admin startproject practice_project
$ python manage.py makemigrations
$ python manage.py migrate
$ python manage.py startapp testApp
Add the testApp to INSTALLED_APPS dictionary

views.py
1. function based views
2. class based views

Create an application level URLs.py
Calling application level URLs from project level urls.py file

* Setting up templates for the project
--------------------------------------------------------------------------
    Create templates named folder within your project's Base directory
    Create testApp named folder inside BASE_DIR/templates folder (will hold testApp related templates)
    Add templates folder to settings.py file so Django is aware of our templates.

    DIRS key needs to be popullated with our templates folder (os.path.join(BASE_DIR,  'templates'))
        TEMPLATES = [
            {
                'BACKEND': 'django.template.backends.django.DjangoTemplates',
                'DIRS': [os.path.join(BASE_DIR,  'templates')],
                'APP_DIRS': True,
                'OPTIONS': {
                    'context_processors': [
                        'django.template.context_processors.debug',
                        'django.template.context_processors.request',
                        'django.contrib.auth.context_processors.auth',
                        'django.contrib.messages.context_processors.messages',
                    ],
                },
            },
        ]

* Setting up static content for the project
--------------------------------------------------------------------------
    Inside,  main project folder, create a folder named static
    WIthin static folder --> images/css/js folder will be created as well

    We  have added TEMPLATE_DIR inside settings.py file, In the same manner we'll add static path settings.

TEMPLATE_DIR = os.path.join(Path(__file__).resolve().parent, 'templates')
STATIC_DIR = os.path.join(Path(__file__).resolve().parent, 'static')

    STATIC_URL = '/static/'
    STATICFILES_DIRS = [STATIC_DIR, ]

To include static files into templates
--------------------------------------
    {% load static %} --> All static files will be available to our html template.

To include css files into template
--------------------------------------
    <link rel='stylesheet' href='demo.css'>                     # general manner
    <link rel="stylesheet" href="{% static 'css/demo.css' %}">  # Django manner

{{ msg }} --> template tag to insert simple data
{%  %} --> 

To insert images:
--------------------------------------
    <img src="{% static 'images/jenkins.png' %}">

Navigating to different page:
--------------------------------------
    <a href="/staticView">Click here for image</a>

Admin Panel:

When I want to display some columns in admin panel
--------------------------------------------------
    class StudentAdmin(admin.ModelAdmin):
        list_display = ['name', 'marks']

    admin.site.register(Student, StudentAdmin)

Django forms:
--------------------------------------------------
1. Validations are very easy with forms
2. Creation of forms, based on models are very easy
3. HTML form widgets
    
    Inside models.py file - 
    class Student(models.Model):
        name = models.CharField(max_length=100)
        marks = models.IntegerField()

    Inside forms.py file - 
    from django import forms
    class StudentForm(forms.Form):
        name = forms.CharField()
        marks = forms.IntegerField()

    Inside views.py - 
    form = forms.StudentForm()

    - Send it to template file
    context_dict = {'form': form}
    return render(request, 'testApp/student_regitration.html', context=context_dict)

    Inside template.html - 
    <body>
        {{ form }}
    </body>

With this method, a form will be generated when we'll navigate to respective URL
    <body>
        {{ form.as_p }}
    </body>

    This will make all the text fields display vertically and not horizontally.

    Form is now available and we may need to submit the data filled in text boxes:

    <body>
    <form method="POST">
        {{ form.as_p }}
        {% csrf_token %}                # this will be changing at every request and django will take care of it.
                                        # In our form, django will add one hidden form field
    <input type="submit" value="Register">
    </form>
    </body>    

We didn't specify any action (such as when button is clicked then where the request will go, so it'll automatically
be going to the same views function), which we can capture from request.POST and will use form to save the data

    def thankyou_view(request):
        return render(request, 'testApp/thankyou.html')

    def studentFeedback(request):
        form = StudentFeedbackForm()
        if request.method == "POST":
            form = StudentFeedbackForm(request.POST)
            if form.is_valid():
                print("Form validation success, printing feedback information")
                print(form.cleaned_data)
                return thankyou_view(request)
        return render(request, 'testApp/student_feedback.html', {'form': form})

We can now apply the restrictions/validation on data such that:
    Email should be in proper format
    Age cannot greater than 100 years like that

Inside forms.py file, there are 2 types of validations available:
    1. Explicit validation by developer using clean methods
    2. Implicit validation by Django.

    I want to put a validation that name should always be atleast 4 characters then, we'll be writing clean method
    for name attribute such as: def clean_name(self)

    from django import forms
    class StudentForm(forms.Form):
        name = forms.CharField()
        marks = forms.IntegerField()
        feedback = forms.CharField(widget=forms.Textarea)   # widget=forms.Textarea makes feedback as TextArea

        def clean_name(self):
            inputname = self.cleaned_data['name']
            if len(inputname) < 4:
                raise forms.validationError('Name should atleast be 4 characters')
            return inputname

    In the same manner, we can write explicit clean method for all the attributes

We can also use Implicit validations, say --> feedback can max be of 40 characters

        from django.core import validators
        from django import forms
        class StudentForm(forms.Form):
            name = forms.CharField()
            marks = forms.IntegerField()
            forms.CharField(widget=forms.Textarea, validators=[validators.MaxLengthValidator(40), 
        validators.MinLengthValidator(10)])

We can also write our own validators too. 

        from django.core import validators
        from django import forms

        def starts_with_t(value):
            if value[0] != 't'
                raise forms.validationError('Name should start with t')

        class StudentForm(forms.Form):
            name = forms.CharField(validators=[starts_with_t])
            marks = forms.IntegerField()
            forms.CharField(widget=forms.Textarea)

Now, rather than writing various clean method for each & every field, we can write a single clean method for the 
whole form.

        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField()
            password  = 
            feedback = forms.CharField(widget=forms.Textarea)
            
            def clean(self):
                cleaned_data = super(StudentFeedbackForm, self).clean()
                inputname = cleaned_data['name']
                if len(inputname) < 4:
                    raise forms.ValidationError('Name should atleast be 4 characters')

                inputfeedback = cleaned_data['feedback']
                if 'feedback' not in inputfeedback:
                    raise forms.ValidationError('Feedback keyword is expected')

                return cleaned_data

We can also compare 2 input fields within the clean method as below:

        class StudentFeedbackForm(forms.Form):
            name = forms.CharField()
            rollno = forms.IntegerField()
            email = forms.EmailField()
            password  = forms.CharField(widget=forms.PasswordInput)
            rpassword = forms.CharField(widget=forms.PasswordInput)
            feedback = forms.CharField(widget=forms.Textarea)

            def clean(self):
                inputpwd = cleaned_data['password']
                inputrpwd = cleaned_data['rpassword']
                if inputpwd != inputrpwd:
                    raise forms.ValidationError('Passwords does not match!')

                return cleaned_data