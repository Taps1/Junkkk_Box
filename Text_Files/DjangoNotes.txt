app.py: this is a configuration file of the app itself.

tests.py: this file is used to write unit tests for the app.

In URLs.py: url(r'^$', views.home, name='home') checks for an empty path

sudo pip insall django
django-admin startproject my_project
django-admin 
Settings: Set your time zone TIME_ZONE
django.contrib.admin -- admin site
django.contrib.auth -- authentication system
django.contrib.contenttypes -- framework for content types.
django.contrib.sessions -- session framework
django.contrib.messages -- messaging framework
django.contrib.staticfiles -- framework to manage static files
django.db import models

python manage.py migrate
python manage.py runserver
python manage.py startapp app_name


python manage.py check -- will check if there's no problem in project without touching database.
python manage.py shell
	q = Question.objects.get(pk=1)
	q.choice_set.all()
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.create(arg1="", arg2="")
	q.choice_set.all()
	Choice.objects.filter(question__pub_date__year=currentyear)
	Choice.objects.filter(choice_text__startswith="")

python manage.py createsuperuser

mysite/settings.py

	TEMPLATES = [
	    {
		'BACKEND': 'django.template.backends.django.DjangoTemplates',
		'DIRS': [os.path.join(BASE_DIR, 'templates')],
		'APP_DIRS': True,
		'OPTIONS': {
		    'context_processors': [
		        'django.template.context_processors.debug',
		        'django.template.context_processors.request',
		        'django.contrib.auth.context_processors.auth',
		        'django.contrib.messages.context_processors.messages',
		    ],
		},
	    },
	]


Where are the Django files:
	$ python -c "
	import sys
	sys.path = sys.path[1:]
	import django
	print(django.__path__)"

<PRIMARY KEY AND FOREIGN KEY MODELS>:
	class A():
		aa = '123'
		bb = models.ForeignKey(bb, null=True, blank=True)

	class B():
		id = '345'
		ff = 'abc'
		dd = 'def'
		ee = 'fgh'

	Now A has foreignKey defined and pointing to B.
	Now I want to fetch the data of class B by object of class A

	obj_A = A.objects.filter(aa='123')
	obj_A.bb.id
	obj_A.bb.dd
	obj_A.bb.ee

    Now I want to fetch data of Class A by class B.
    obj_B = B.objects.filter(id='345')        
    obj_B.A_set.all()[0].aa
    obj_B.A_set.all()[0].bb

<CLASS BASED VIEWS>:
    If the request is a POST, it will execute the post() method inside the view, if the request is a GET, it will execute the get() method inside the view.

from django.views import View

    class ContactView(View):
        def get(self, request):
            # Code block for GET request

        def post(self, request):
            # Code block for POST request

    urlpatterns = [
        url(r'contact/$', views.ContactView.as_view(), name='contact'),
        ]

<FUNCTION BASED VIEWS>:
    In function-based views, this logic is handled with if statements:
    def contact(request):
        if request.method == 'POST':
            # Code block for POST request
        else:
            # Code block for GET request (will also match PUT, HEAD, DELETE, etc) 

    urlpatterns = [
        url(r'contact/$', views.contact, name='contact'),
        ]

    # -*- coding: utf-8 -*-
    from __future__ import unicode_literals

    from django.db import models
    from django.contrib.auth.models import User

    # Create your models here.
    class Board(models.Model):
        name = models.CharField(max_length=30, unique=True)
        description = models.CharField(max_length=100)

        def __str__(self):
            return self.name        # will give self.name when accessed

    class Topic(models.Model):
        subject = models.CharField(max_length=255)
        last_updated = models.DateTimeField(auto_now_add=True)
        board = models.ForeignKey(Board, related_name='topics')
        starter = models.ForeignKey(User, related_name='topics')

    class Post(models.Model):
        message = models.TextField(max_length=4000)
        topic = models.ForeignKey(Topic, related_name='posts')
        created_at=models.DateTimeField(auto_now_add=True)
        updated_at = models.DateTimeField(null=True)
        created_by = models.ForeignKey(User, related_name='posts')
        updated_by = models.ForeignKey(User, null=True, related_name='+')

    >>> from apps.boards.models import Board
    >>> board = Board(name="Django", description="This is a board about Django")
    >>> board.save()
    >>> board.id
        1
    >>> board.name
        'Django'
    >>> board.description
        'This is a board about Django'
    >>> board.description = 'Django discussion board.'
    >>> board.save()

Every django model comes with a Model manager attribute, we can access it via python attribute objects.
It is mainly used to execute queries on the database: 
    >>> board = Board.objects.create(name="Python", description="General discussion")
    >>> board.id
        1
    >>> board.name
        "Python"

    >>> board = Board.objects.all()
    >>> board = Board.objects.get(id=2)


    Create an object without saving:            board = Board()
    Save an object (create or update)           board.save()
    Create and save an object in db             Board.objects.create(name='...', description='...')
    List all objects                            Board.objects.all()
    Get a single obj identified by a field      Board.objects.get(id=1)
