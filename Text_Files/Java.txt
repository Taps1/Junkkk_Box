Originated by Sun microsystem but now acquired by Oracle. Categorized into 3 parts:
	J2SE - Core Java - Classes/Interfaces (StandAlone programs)
	J2EE - Advanced Java - (Servlet, JSP, EJB to write Web application)
	J2ME - Mobile Designing

JDBC: Use to interact with Databases. (Connection with Database) [Doesn’t hold any full form, But a trademark]
AWT - SWING: Abstract Window tool kit (To develop desktop applications)
	java -version

Write Once, Run anywhere — (Platform Independent, Architectural Neutral<IBM, Sunmicro, Apple inc.>)
Class oriented language

	javac filename.java	<will be compiled>
	java HelloWorld	<will be executed>

I’ll be compiling this file with version(1.8) and can put compiled file onto some system which has completely different architecture (Java installation is required), It’ll be executed, But If I put compiled file(.class) to lower version compared to that In which it was compiled then major-minor version error will be thrown. But program compiled in lower version can be executed in higher version.
	Java compiled in 1.8 won’t execute in 1.7
	Java compiled in 1.2 will get execute in 1.8

Java software(which we install is platform dependent) - Java for Mac, Java for Windows, Java for Linux
But Once the file is compiled, .class file is uniformed

As of now, When I compiled the file, if there’s public in definition of class, then className and fileName must be same.
and Compiled file will be created with the name of ClassName. With public - FileName must be same as of ClassName

We’ve 8 datatypes: byte, boolean, char, short, int, float, long, double
We’ve 5 exceptions: try, throw, throws, catch, finally
We’ve 11 modifiers: private, public, protected, static, final, volatile, native, abstract, transient, synchronised, strictfp
We’ve 11 Classes and Object: class, interface, enum, extends, implements, this, super, instanceof, package, import, new
We’ve 10 conditions and Loop: for, while, do, continue, break, switch, case, default, if, else
We’ve 2 unused keywords: goto, const
We’ve 2 method keywords: void, return and 1 assert
We’ve 3 literals: true, false, Null

When we install JAVA, We receive two folders - JDK & JRE 
(JDK is in C:/Program_Files/Java/JDK.<version>/)
(JRE is in C:/Program_Files/Java/JRE.<version>/)

Where JDK has javac.exe and java.exe both file and is primarily for Programmer to compile the <file_name>.java file
Whereas JRE only has java.exe file and is available for Client and for programmer as well.
So In case, Anyone wants the program, Then I will simply install JRE and will give him compiled files (<file_name>.class)

Until, javac is not identified, No program will be compiled So We need to set the PATH
When class is defined as public, then ClassName and FileName must be same.

javac HelloWorld.java —> ///invokes the compiler
java Test	      —> ///invokes JVM for execution

Do main() method has to be public?
	Compiled class goes to JVM’s memory, When main() is not public then JVM will not be able to locate main() method, So main() method needs to be defined as public. So In case main() is not public then It’ll get compiled but won’t get executed.

Do main() method has to be static?
	JVM should be able to call main() and internally JVM code that calls main() is written in static blocks. Yes, Otherwise JVM can’t call it directly.

class Test
	{
		static void main1(String suraj[])
		{
			System.out.println(“Hello World”);
		}
	}

public class JVMTest
	{
		public static void main(String args[])
		{
			Test.main1(args);
		}
	}

If there’s no static in called class, Then I will have to create an object of Test class and only then I would be able to access it via Object.
	Test t = new Test();
	t.main1(args);

Now, After compiling this as javac JVMTest.java, Two .class files are created 1. Test.class	2.JVMTest.class

What is void in main()?
	JVM calls main() and main() is void which means that main is not going to return any value back to JVM.

What is String args[]? Why it’s an array?
	java JVMTest 100 50 —> Arguments to main() method, args.lenght == 2, Arguments are received as strings - So type casting is also required, To get them:
	args[0], args[1]

What If String args[] is not declared as array:
	Exception will be thrown, Compilation is successful but failed to execute

<Method Overloading>:
	Different type of arguments with same name of function.
	We must have Only one main() method per class, But of main(String args[]) type, rest we can have any number of. JVM only checks for main() method which has exact same signature as: “public static void main(String args[])”

All predefined class and interfaces in java are not keywords and We can use them as identifiers but not recommended.

Datatypes: Byte, Boolean(1 byte), Short, Char(2 bytes), Int, float(4 bytes), long, double(8 bytes)
	Category Wise: 
		3 Category:
			1. Character Type	2.Boolean Type	3.Numeric
									- Integral type(byte, short, int, long)
									- Floating point type(float, double)
		byte: 1 byte - 8 bits
		Range: -(2^7) to (2^7)-1 # Values from -128 to 127 can be assigned (For rest value, error will be thrown)
		byte b1 = 10; //valid
		byte b2 = 128; // invalid
		byte b3 = 127; //valid
		b3 += 5 = -123; //Cycle
	
		Short: -(2^15) to (2^15)-1

		Integer: 4 bytes: -(2^31) to (2^31)-1

		long: 8 bytes: 64 bits: -(2^63) to +(2^63) - 1
	
		float: 4 bytes: -(3.4e38) to +(3.4e38)
	
		double: 8 bytes: -(1.79e^308) to +(1.79e^308)
	
		char: 2 bytes
			
		long variable is of 8 bytes and float type of variable is of 4 bytes, Still maximum value of long(2^x) can easily be stored in float type variable(3.4e^x).

		Cycle methodology is applicable for all integer types
	
	