Originated by Sun microsystem but now acquired by Oracle. Categorized into 3 parts:
	J2SE - Core Java - Classes/Interfaces (StandAlone programs)
	J2EE - Advanced Java - (Servlet, JSP, EJB to write Web application)
	J2ME - Mobile Designing

JDBC: Use to interact with Databases. (Connection with Database) [Doesn’t hold any full form, But a trademark]
AWT - SWING: Abstract Window tool kit (To develop desktop applications)
	java -version

Write Once, Run anywhere — (Platform Independent, Architectural Neutral<IBM, Sunmicro, Apple inc.>)
Class oriented language

	javac filename.java	<will be compiled>
	java HelloWorld	<will be executed>

I’ll be compiling this file with version(1.8) and can put compiled file onto some system which has completely different architecture (Java installation is required), It’ll be executed, But If I put compiled file(.class) to lower version compared to that In which it was compiled then major-minor version error will be thrown. But program compiled in lower version can be executed in higher version.
	Java compiled in 1.8 won’t execute in 1.7
	Java compiled in 1.2 will get execute in 1.8

Java software(which we install is platform dependent) - Java for Mac, Java for Windows, Java for Linux
But Once the file is compiled, .class file is uniformed


As of now, When I compiled the file, If className is different from fileName, then “public” shouldn’t be there while defining class name
and Compiled file will be created with the name of ClassName.

We’ve 8 datatypes: byte, boolean, char, short, int, float, long, double
We’ve 5 exceptions: try, throw, throws, catch, finally
We’ve 11 modifiers: private, public, protected, static, final, volatile, native, abstract, transient, synchronised, strictfp
We’ve 11 Classes and Object: class, interface, enum, extends, implements, this, super, instanceof, package, import, new
We’ve 10 conditions and Loop: for, while, do, continue, break, switch, case, default, if, else
We’ve 2 unused keywords: goto, const
We’ve 2 method keywords: void, return and 1 assert
We’ve 3 literals: true, false, Null

When we install JAVA, We receive two folders - JDK & JRE 
(JDK is in C:/Program_Files/Java/JDK.<version>/)
(JRE is in C:/Program_Files/Java/JRE.<version>/)

Where JDK has javac.exe and java.exe both file and is primarily for Programmer to compile the <file_name>.java file
Whereas JRE only has java.exe file and is available for Client and for programmer as well.
So In case, Anyone wants the program, Then I will simply install JRE and will give him compiled files (<file_name>.class)

Until, javac is not identified, No program will be compiled So We need to set the PATH
When class is defined as public, then ClassName and FileName must be same.

javac HelloWorld.java —> ///invokes the compiler
java Test	      —> ///invokes JVM for execution

Do main() method has to be public?
	Compiled class goes to JVM’s memory, When main() is not public then JVM will not be able to locate main() method, So main() method needs to be defined as public. So In case main() is not public then It’ll get compiled but won’t get executed.

Do main() method has to be static?
	JVM should be able to call main() and internally JVM code that calls main() is written in static blocks. Yes, Otherwise JVM can’t call it directly but with Object.

class Test
	{
		static void main1(String suraj[])
		{
			System.out.println(“Hello World”);
		}
	}

public class JVMTest
	{
		public static void main(String args[])
		{
			Test.main1(args);
		}
	}

If there’s no static in called class, Then I will have to create an object of Test class and only then I would be able to access it via Object.
	Test t = new Test();
	t.main1(args);

Now, After compiling this as javac JVMTest.java, Two .class files are created 1. Test.class	2.JVMTest.class

What is void in main()?
	JVM calls main() and main() is void which means that main is not going to return any value back to JVM.

What is String args[]? Why it’s an array?
	java JVMTest 100 50 —> Arguments to main() method, args.lenght == 2, Arguments are received as strings - So type casting is also required, To get them:
	args[0], args[1]

What If String args[] is not declared as array:
	Exception will be thrown, Compilation is successful but failed to execute
