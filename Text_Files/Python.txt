Code refactoring is restructuring the existing code without changing its external behaviour.
If you want to get help regarding the python via prompt; check with help() on terminal

a module is a python file and package is a module which contains any other modules.

If I want to check whether the sequence container is empty or not Simply Use:
	bool(sequence)

exec takes statements<won't give values> and eval takes expressions<will return values>

Python programs are run by two methodologies:
	Interactive mode (>>> chevron prompt)
	Script mode (save a file and run that .py file)

<INTEGER>
Simple Integer Functions:
	x=10
	type(x)				# <type 'int'>
	x**2				#100<Exponent Power>
	hash('Python')			#Return the hash value for word
	round(2.554)
	abs(number)			#Return the absolute value for the number (No -/+)
	max(sequence)			#Return the Maximum Value from the sequence
	min(sequence)			#Return the Minimum value from the sequence
	>>>1,00,000			#(1,0,0) Python will take it as comma separated Integers.	
	>>>z=0123			#Octal Value
	>>>z=0128			#Syntax Errors

_______________________________________________________________________________________________________________________________________________________________
	
<COMPLEX>
Simple Complex Number:
	x=5+6j				# Complex Number
	dir(x)

	x.real
	x.imag

_______________________________________________________________________________________________________________________________________________________________

<STRING>
Simple Strings:
	s1="Talat"
	s2="Parwez"
	s1+s2
	s1*5				#"TalatTalatTalatTalatTalat"
	len(s)				#5
	s=" I went there "	
	s.lstrip()			#"I went there	"
	s.rstrip()			#"  I went there"
	s.strip()			#"I went there"
	'I' in s			#True
	s="Hello Talat"		
	s.split()			#["Hello","Talat"]
	list(s)				#['T','a','l','a','t']
	set(s)				#(['a','t','T','l'])
	id(s)				# id(s) and hash(s) are not same
	string.lower
	string.upper
	string.swapcase()
	ord('A')			#will print the ASCII value
	chr(65)				#will print the ordinal value of ASCII value
	s='xxyy'			
	s.replace('x','786')		#will replace the x with '786' at all positions
	s.find('y')			#Return the first occurance Index of 'y'
	s.rfind('y')			#Return the Last occurance index of 'y'
	s.title				#Will Capitalize the first letter of the string.
	s.rjust(10,' ')			#Will shift the string to 10 characters right.
	s.ljust(10,' ')			#Will shift the string to 10 characters left
	len('\t')			#1
	len(r'\t')			#2
	s.count(g)
	s='xyz'
	max(s)				#will return z
	s.startswith('x')		#Will return True
	s="Hello \			#Will merge it to a single line
	   Talat"
    s1='Talat'  
    s2='Parwez'         
    "{0}{1}".format(s1, s2)
    "%s%s"%(s1, s2)

Reversing the string:
	s='Hello'
	s[::-1]				#It will reverse the string as "olleH"

Joining the string:
	w=["I","am","Good"]
	' '.join(w)

_______________________________________________________________________________________________________________________________________________________________
		

Range Function:
	range(10)			#[0,1,2,3,4,5,6,7,8,9]
	range(2,10)			#[2,3,4,5,6,7,8,9]
	range(2,10,2)			#[2,4,6,8]
	range(10,2)			#[]
	range(10,2,-1)			#[10,9,8,7,6,5,4,3]

_______________________________________________________________________________________________________________________________________________________________

<LIST>
Simple List Functions:
        # append will simply append the item as it is, Whereas extend adds the item iteratively
	fruits=['a','b','c']
	fruits[0]			#'a'
	fruits.append('d')		#['a','b','c','d']
        fruits.append(['e'])		#['a', 'b', 'c', 'd', ['e']]
	fruits.extend(['f'])		#['a', 'b', 'c', 'd', ['e'], 'f']
	fruits.index('a')		#0
	fruits.index('a',1)		#It will find the element 'a' from index 1
	fruits_copy=fruits[:]		#will copy the whole list<shadow copy>
	a=[1,2,3],b=[4,5,6]
	zip(a, b)--> [(1,4),(2,5),(3,6)]
	In Python2, xrange() act as Generator and In python2, range() act as Generator
	

To delete an object:
	del "object_name"

Loopings in List:
	for i in fruits:
		print i,		#a b c d 
	
	for i in range(len(fruits)):
		print i,		#0 1 2 3

	for i in enumerate(fruits):
		print i,		#(0,'a')(1,'b')(2,'c')(3,'d')	

	for i in enumerate(fruits):
		print i[0],i[1]		#0 a 1 b 2 c 3 d

	for idx,item in enumerate(fruits):
		print idx,item		#0 a 1 b 2 c 3 d 

	fruits.pop			#remove last inserted item
	fruits.pop(2)			#remove location specified item
	fruits.remove('a')		#specified item get removed
	fruits.append('b')		#will insert into last of list
	fruits.insert(1,'b')		#will insert into specified Location
	fruits[0]='a'
	del l[0]			#will remove only 'a'
	l1=['a','b']
	l2=['c','d']
	l3=l1+l2			#['a','b','c','d']

Sorting of a List:
	l1.sort()			#will sort the list
	sorted(l)			#return the sorted item but didn't sort the actual list

Reversing a list:
	l1.reverse()			#will reverse the given list
	reversed(l1)			#return the reversed item's list but didn't reverse the actual list

Undoing the sorted list:
	random.shuffle(l)		#Undo the sorted list

Counting the List:
	l1.count('item')		#will give the number of occurances of itemn in the sequence

List Comprehension:
	for the given sequence if I want to iterate over the sequence Then I'll preferrably chose the Traditional for Loop, 
	But better to use the List Comprehension As It will reduce the code.
		x=[item for item in sequence]
		x=[item for item in sequence condition]
		x=[item for element in sequence for item in element ]
		first one is outer loop and second one is inner loop.

_______________________________________________________________________________________________________________________________________________________________

<TUPLE>
simple tuple functions:

	tuple(sequence)
	t=x,y=10,20			#x,y values will be given to t as (x,y) in form of tuple
	t[i]				#indexing can be performed on tuples
	t=(1,)				#A tuple with a single element

_______________________________________________________________________________________________________________________________________________________________

<DICTIONARY>
<Dictionaries are the unordered sequence>

	d={}				#Empty dictionary
	d={1:'a',2:'b'}			#Key-Value Pairs
	d.keys()			#Return the Keys in a List
	d.values()			#Return the values in a List	
	d.items()			#Return the (key,value)
	q=d.get(key, default_value)	#will return the Value for the Key-->  <request.get("params",0)>
	q=d.get(key,'Message')		#Will return the Message if value for key was not returned
	d[i][j]				#Dictionaries can be indexed with their keys
	d.has_key(key)			#Will return True or False if key was found or not
	d.update(d1)			#It will update the d by adding key-values of d1 and If keys are same both dictionaries then keys of d1 will be given the priority
	d.setdefault("key",value)	#Will set a default value to the key If key is not present already
	d.setdefault("key",[]).append("value")	#{"key":""}
	d.iteritems()			# returns the dictionary-itemiterator

_______________________________________________________________________________________________________________________________________________________________
<ALL>
	all() will return True if all elements in an iterable are True	

<ANY>
	any() will return True if any of the elements in an iterable is True


<FILE OPERATION>
	
	for loop can also work with the file object
         r --> read only
         w --> if file exists, delete all content and open it to write
         a --> Append to the existing content

	Make a text File as text.txt, 	['r', 'w', 'a']
	data='Some String'
       	f.read()			#will read the whole file at a once
	f.readline()		        #will read the lines one by one 
        f.readlines()                   #Will read all the lines in a List
	f=open('test.txt','mode')

	f.write('data')
	f.writelines('data')
	f.append('data')
	f.read(30)			#will read first 30 characters
	f.read(30)			#next 30 characters
	f.seek(0)			#will move the pointer to 0th index
        f.seek(-3, 2 )                  #Go to 3rd byte from the end ... [1 start of file, 2 end of file]
	f.tell()			#will tell the pointer's position(Offset position)

	with keyword is also used to open a file and it will automatically close the file when goes out of the scope.
		with open('file_name.txt') as f:
			//statements

       #!/usr/bin/python
       import time
       import os
       # Open a file
       outputFile = open("bb.py","a") # outputFile = open("bb.py”,”a”, 0)
       outputFile.write("First")
       outputFile.flush()
       #print "Now you have 10sec to see that outputFile.txt is still the same as before"
       time.sleep(10)
       outputFile.write("Second")
       print "Now if you look at outputFile.txt you will see 'First' and 'Second'"

	###USECASE:
		When we write firstly into file, and after some time we write secondly into file, The program waits for the complete execution till the first write can happen, So In order to write into the file immediately(When LOC occurs), We need to use file_object.FLUSH() method

_______________________________________________________________________________________________________________________________________________________________
		

<EXCEPTION HANDLING>
	try:
		//some_Operation
	except:
		//Print this error

	It will try to perform operation defined in try block and if it failed then will print the error what you've defined in your except
	

	1)	try:
			//some_Operation
		except ErrorType as e:
			//print e error

	this is like if-else block; Try to perform some opration and the interpreter is not able to perform those oprations defined in try 
	block then go to except(else) block; If It catches the exception defined in except block the go to except execution;

	for example:
		
		try:
			f=open('test.tx')
			print f.read()
			f.close()
		except ValueError as E:
			print "Error has been Caught",E

	It will try to perform all oprations defined in try block and if it catches the ValueError, Then will print the eror message
        
        If I want that this statement should be executed under all circumstances then, use finally block
                try:
                    f=open("file.txt",'w')
                    t=12/0
                except ZeroDivisionError:
                    print "Can't be divided by Zero"
                finally:
                    f.close()
                    print "Closing the File object"


The Last printed expression will be assigned to the variable _ (underscore)

_______________________________________________________________________________________________________________________________________________________________

<SETS>
	These are the lists without duplication
	They cannot be accessed by indexing
	l=[0,1,2,3,1]
	set(l)--> set([0,1,2,3])
	s=set([1,2,3,4])
	s.add(9)			#Will add '9'		
	s.discard(1)			#will discard '1' from the sequence
	s.union(s1)
	s.intersection(s1)
	s.difference(s1)
	str="talat"	
	set(str)			#set(['a', 't', 'l'])
	s1.issubset(s2)
	s1.issuperset(s2)

_______________________________________________________________________________________________________________________________________________________________

Methods without self are considered as Global Functions

<MRO>	Method Resolution Order
	Will look for the element firstly in <current><parent><grand-parent><object>
	mro[1]--> Runtime Error
	mro[2]--> Standard Error 
	mro[3]--> Exception Error
	mro[4]--> Base Exception Error

_______________________________________________________________________________________________________________________________________________________________

<HIGHER ORDER FUNCTIONS>
        A function which does atleat one of the following:
                Takes one or more functions as an argument.
                Returns other function as an Output.

<LAMBDA>
	Lambda functions are also known as Anonymous function
	One liner function which don't have any definition, They're just assigned to a variable and that variable will receive the arguments
		
		lambda args: <executablity>
		g = lambda x, y: x**y
		g(2,5)


<MAP>
	It takes one function and an iterator as input and applies the function on each value of the iterator and returns a list of result.
		map(funtion_name_to_be_mapped,sequence)
		output form--> list []
			
			l=[1,2,3,4,5,6,7,8,9]
			def square(num):
				return num*num

			print map(square, l)
			map(g, [1,2,3,4], [4,3,2,1])

<REDUCE>
	It takes one function and an iterator as an Input and execution goes in this way: Take 2 elements of the sequence and perform operate on them and keeps going on in the same manner.
		find the maximum value from the sequence:
		lst = [12, 32, 1, 87, 9, 5, 43]
		
		reduce(lambda a, b: a if a>b else b, lst)

<FILTER>
	It offers a convenient way to filter out all the elements of an iterable, for which the function returns True

	lst = [12, 21, 23, 54, 65, 56, 98. 89]
	filter(lambda a: True if a%2 == 0 else False, lst) -> [12, 54, 56, 98]
	filter(lambda a: a%2 == 0 , lst)
	
	The function needs to return Boolean value (True/False), This function will be applied to every element of the iterable, Only if the function returns True for an element - that element will be included in the result 

_______________________________________________________________________________________________________________________________________________________________

<FUNCTION>
	object is the upper most class in python.
	issubclass(int,object)--> will return True
	functions have function definition and defined by def keyword, here is the most basic syntax of the Python function
		
1)		def foo():	
			return 1
		foo()
			1


2) 		a="This is a global string"
		def foo():
			print locals()
		print globals()		#will print {'a': 'Ths is global String', '__builtins__': <module '__builtin__' (built-in)>, '__package__': None, '__name__': 						'__main__', 'foo': <function foo at 0xb76a0d14>, '__doc__': None}

		foo()			#will print {}


3)		a="This is a global string"
		def foo():
			a="This is a Local string"
			print locals()
		foo()			#will print This is a local string
		a			#wll print a as it was before calling the function
		print globals()		#will print a as it was before caaling the function



4)		def foo(x):
			print locals()
		foo(1)			#will print {'x':1}



5)		def foo(x,y=0):		#function with default parameters
			return x+y
		foo(1,2)
		foo(1)


6)		def foo(x,y):
			return x+y
		foo(y=2,x=4)		#function with Named arguments


7)	Functions can be passed as an Arguments in Python. 
		def add(x,y):
			return x+y
		def sub(x,y):
			return x-y
		def apply(func,x,y):
			return func(x,y)
		apply(add,4,5)
		apply(sub,4,5)


8)	Outer and Inner function
		def outer():
			x=1
			def inner():
				print x
			return inner				//when you put parentheses around it the function gets executed whereas if you don’t put parenthesis around 									  it then it can be passed around and can be assigned to other variables without executing it.
		foo=outer()
		foo			#function inner at one position
		foo()			#It will return the value from inner function



9)	Variable number of Arguments
		def foo(*args):
			print args			// It will print the recieved arguments in form of Tuples

		def foo(*args);
   			print args
		
		ll = [1,2,3,4]
		foo(*ll) 				// (1,2,3,4)
		foo([1,2,3,4])				// ([1,2,3,4],)

	Another use of *(asterisk):
		l=[1,2]
		def foo(x,y):
			return x+y
		foo(l[0],l[1])				//Not a good Manner
		foo(*l)					//elements of list will go one by one


10) 	Variable Number of Arguments in Key-Value pair
		def foo(**kwargs):
			print kwargs			//will return {x:1,y:2}
		foo(x=1,y=2)

		d={'a':1,'b':2}
		def foo(a,b):
			return a+b	
		foo(d['a'],d['b'])			//'3'  | Values will get added
		foo(*d)					//'ab' | keys will get merged
		foo(**d)				//'3'  | Values will get added

_____________________________________________________________________________________________________________________________________________________________

<ITERATORS>
	
	Iterators have the special property to keep the one value @once. 
			
			iter(sequence)
			number='123456789'
			n=iter(number)
			n.next(),n.next()..... after reaching out the last element, It will throw an StopIteration Exception.
		We don’t get StopIteration error with for loop, because for loop automatically catches the exception and stops calling next() on iterable.


If I want to check whether the file is having syntax file or not:
	We can use the py_compile site package. 

		python -m py_compile "filename"
	
	It will give you what syntax error you have and in which line

_______________________________________________________________________________________________________________________________________________________________

<FUNCTIONS WITHIN FUNCTIONS>
	def hello(name="Jose"):
            print "The hell() function has been executed"
            def greet():
                return "Inside greet() function"
            def welcome():
                return "Inside welcome() function"
            print greet()
            print welcome()

hello(): 
The hell() function has been executed
Inside greet() function
Inside welcome() function
_______________________________________________________________________________________________________________________________________________________________

<DECORATOR>
	A decorator is just a callable that takes a function as an Argument and return a replacement function. These are simply wrappers to existing functions.

					"""def foo(bar):
					    return bar + 1

					print foo(2) == 3
					-------------------------------------------------------------
					Nested Function:
					--------------------------------------------------------------

					def parent(number):
					    print "Printing from parent function"

					    def first():
					        print "first child"
					    def second():
					        print "second child"
					    def third():
					        print "third child"

					    try:
					       assert number == 10
					       return first()
					    except AssertionError:
					       return second()

					parent(18)


					------------------------------------------------------------
					Decorator Call to function
					------------------------------------------------------------

					def my_decorator(some_func):
					    def wrapper():
					        print "Something is happening before some_function() is called"
					        some_func()
					        print "Something is happening after some_function() is called"
					    
					    return wrapper

					def just_some_function():
					    print "Wwheee!!"


					just_some_function = my_decorator(just_some_function)()
					#just_some_function()


					-------------------------------------------------------
					Decorator Call to function with "PIE" syntax
					-------------------------------------------------------
					"""
					def my_decorator(some_func):
					    def wrapper():
					        print "Something is happening before some_function() is called"
					        some_func()
					        print "Something is happening after some_function() is called"
					    
					    return wrapper

					@my_decorator
					def just_some_function():
					    print "Wwheee!!"


					just_some_function()


					-------------------------------------------------------
					Some real word examples
					-------------------------------------------------------
					"""
					from time import sleep

					def sleep_decorator(function):
					    def wrapper(*args, **kwargs):
					        sleep(2)
					        return function(*args, **kwargs)
					    return wrapper

					@sleep_decorator
					def print_number(num):
					    print num

					print_number(10)

_______________________________________________________________________________________________________________________________________________________________

<GENERATOR>

	Normal functions returns value only single time; But what if I want to get the next value and to continue over the whole return .... There I will use yield ... by which 		we can continue our looping from where we left.
    Generator is a function that returns an object on which we can perform next() operation
	Generators are a tool for creating iterators.They use to YIELD the data whenever they want to return the data
	Each time the next() is called, Generator resumes from where it left-off


	With generators, __iter__() and next() method got created automatically;
	If In a method there is a yield keyword, Then It will automatically be converted into generators.

	We should have the ability to create the function which can yield(giving) the series of value instead of simply returning the single value
	When a function is called, all the work done by function and stored in local variables is lost, A new call to the function creates 
	everything from the scratch.
	return implies that the function is returning control of execution to the point where the function was called.
 	"Yield," however, implies that the transfer of control is temporary and voluntary, and our function expects to regain it in the future.
	Basically
		"When we use return, The control goes to the calling function and all the work done by the function goes lost,
		Now If I want to regain it again in the future, Will I be able to regain it? .... NO!!!"
	So, Better to use YIELD <GENERATOR>

		Functions that have the ability to do this, Will be called as Generators

	Generators are like normal functions but whenever they need to generate the value, They dont return but yield them.
		One value is generated from the generator, To get the next generated value, We use __next__() method 



		def foo():
			1.print "I am in First Yield"
			2.yield 1
			3.print "I am in Second Yield"
			4.yield 2
			5.print "I am in Third Yield"
			6.yield 3

		o=foo()
		o.next()			#It will go to line 1 and start execute untill the first yield is reached
		o.next()			#It will go to the immediate next line of the yield where it left; Won't start from line 1 but from 3
		o.next()			#It will go the line where the previous yield was left off.

	When all the values are iterated, stopIteration happened

		l=[1,2,3,4,5,6,7,8,9,,0,4,6,7,3]
		def foo(seq):
			for item in seq:
				yield item
	
		elem=foo(l)
		elem.next()

_______________________________________________________________________________________________________________________________________________________________

<CLASS>
	object.attribute								#[readable and writable also]
	Attributes of an objects are readable/writable and deletable also:
	
	object.attribute=value
	del object.attribute
	
		class MyClass:
	       	"""A simple example class"""
		    i = 12345
		    def f(self):
		        return 'hello world'
	Here i and f are the attributes of the class and can be accessed as MyClass.i and MyClass.f

        If there is a __init__() defined then we've to use the self keyword mandataroly to access that varaible.        
                
        class A(object):
	i,j=11,21
	def __init__(self):
		self.i=10
		self.j=20
	def f(self):
		print A.i                               #11
		print self.j                            #20

	class A(object):
    ...:     d = 123
    ...:     def __init__(self, a):
    ...:         self.a = a
    ...:         print self.a
    ...:         print A.d
    ...:         print self.d

	obj = A(234)
	234, 123, 123
	
	class A(object):
    ...:     d = 123
    ...:     def __init__(self, a):
    ...:         self.a = a
    ...:         print self.a
    ...:         self.d = 456
    ...:         print A.d
    ...:         print self.d
	obj = A(234)
	234, 123, 456

	
	class A(object):
    ...:     d = 123
    ...:     def __init__(self, a):
    ...:         self.a = a
    ...:         print self.a
    ...:         A.d = 456
    ...:         print A.d
    ...:         print self.d
	
	obj = A(234)
	234, 456, 456


	If you want to make an object of it then you need to define it as:	
		
		obj_name=class_name()

	A class also have the magic method named as: __init__(self,arguments)
	While instantiating a class(@time of creation of object), If we pass the arguments as:
		
		obj_name=class_name(arg1,arg2,...)

	They will always be recieved by __init__ method.
	

		class A(object):
			def __init__(self,x,y):
				self.x=x
				self.y=y
		

		t=A(1,2)
		t.x				#1
		t.y				#2

	Object is passed as a self argument to the function and self is used to bind all the class things to that p       particular Object Instance.
	One thing, Why self is used in every method of the class:
	Because, When we say x=A(), Here ,,, Object is passed as an argument to the function.
	Its is like 
				
				x.f()==MyClass.f(x)
	
	self is the object_name that is passed to function.



		class A():
			i=12345						#shared by all instances of the class
			def __init__(self,name):
				self.name=name				#shared by specific instance

			

		x=A()
		x.i								#12345


		class A():
		name1="Python"
		def __init__(self,name,age):
		    self.name=name
		    self.age=age
		    self.name1="TP"
        
		x=A("Talat",22)					#Create the instance of class A
		print x.age						#22
		print x.name					#"Talat"	
		print x.name1					#"TP"

	If self with name1 was not given, then In lack of self keyword, name1 will not engaged with x object and will find to the upper most class. 
	And will take the name1 as "Python".


	If I want to derive a baseclass into derivedclass i.e. Inheritance Concept. The syntax for Inheritance is as follows:
		
		class derived_class(object,base_class):
			//statements
	
	If the class is defined in another module, Then also it can be inherited as:
		
		class derived_class(object,module_name.base_class):
			//statements


	If some attribute is not found in the class<derived>; Then It'll move forward to the BaseClass in searching of that requested Attribute and 
	Search for it goes on untill it finds the requested attribute.

		current class--> parent class--> grand parent class--> Object class(Upper Most Class)

	We can check whether the object is instance of the class or not as : isinstance(obj,class)
	We can check whether the derived_class is subclass of base_class or not as: issubclass(derived_class,base_class)


<SUPER>:
        Super is a keyword that is used to make a call to the super class method's along with current class method:
        suppose there is a class that is been inherited by child class and both of them have the __init__() methods, So without using the super keyword we can;t 
        call the parent class's __init__(), we need to put super keyword in child class that while initializing the current class; the parent class of it also 
        needs to be initialized.
        It's more like How can I call the method of parent class if both child and parent class has the same method name

NOTE: "super() argument 1 must be type, not classobj - If baseclass doesn't have Object class inherited"
        e.g.
           
                                        class A(object):
                                            def __init__(self, a):
                                                self.a = a
                                                print "Class A's constructor"
                                            def foo(self):
                                                print "I'm in class A"
                                            def fo1(self):
                                                print "Class A"

                                        class C(A):
                                            def __init__(self, a):
                                                self.a = a
                                                print "Class C's constructor"
                                                super(C, self).__init__(self.a)
                                            def foo(self):
                                                print "I'm in class C"


                                        class A(object):
                                            #def __init__(self):
                                            #    print "contructor of class A"
                                            #    super(A, self).__init__()
                                            def foo(self, a=5, b=10):
                                                print a+b
                                        class B(A):
                                            def __init__(self):
                                                print "constructor of class B"
                                                super(B, self).foo()
                                        class C(A):
                                            #def __init__(self):
                                            #   print "Consructor for class C"
                                            #    super(C, self).__init__()
                                            def __str__(self):
                                                print "This is an object of class C"
                                            def __call__(self, a, b):
                                                self.a = a
                                                self.b = b
                                            def foo(self):
                                                super(C, self).foo(self.a, self.b)

        
        We can check the mro for the class; as 
                                        class_name.mro()


        When an object is created for a class C; then it'll also call the constructor method of parent class i.e. of class A
                                        obj = C(10)
                                                                o/p will be "Class C's constructor" and then "Class B's constructor"
        Whatever method we'll call in super method's line then it'll be called
	Multiple Inheritance:
		
		class B(object):
			name="Python"

		class A(B):
			def __init__(self,name,age):
				#self.name=name
				self.age=age
				
		x=A("Talat",22)
		print x.age									#22
		print x.name								#Python
		print issubclass(A,object)


	If there is another class that has the same attribute as name, Then which name to call, which class will be looking first,

		So It will be taken according to: 	
											parameter list of the class
											class derived_class(base_class1,base_class2,base_class3)
		First it will find in itself, then base_class1, base_class2, base_class3 and so on...


	Look at the example:

		class Employee:
			pass

		john = Employee() # Create an empty employee record

		# Fill the fields of the record
		john.name = 'John Doe'
		john.dept = 'computer lab'
		john.salary = 1000

	class A():
		def foo(self):
			b=20
			print b

	a=A()
	a.foo()					#20
	hasattr(a,'b')			#False

	class A():
		b=10
		def foo(self):
		    b=20
		    print b
		    print self.b

	a=A()
	a.foo()					#10 \n 20
	hasttr(a,'b')			#True




        class Person(object):
                """
                Returns a ```Person``` object with given name.
                """
                def __init__(self, name):
                        self.name = name
                def get_details(self):
                        "Returns a string containing name of the person"
                        return self.name
        class Student(Person):
                """
                Returns a ```Student``` object, takes 3 arguments, name, branch, year.
                """
                def __init__(self, name, branch, year):
                        Person.__init__(self, name)
                        self.branch = branch
                        self.year = year
                def get_details(self):
                        "Returns a string containing student's details."
                        return "%s studies %s and is in %s year." % (self.name, self.branch, self.year)
        class Teacher(Person):
                """
                Returns a ```Teacher``` object, takes a list of strings (list of papers) as
                argument.
                """
                def __init__(self, name, papers):
                        Person.__init__(self, name)
                        self.papers = papers
                def get_details(self):
                        return "%s teaches %s" % (self.name, ','.join(self.papers))

        __call__():
                Call method is used to make the object as a Callable; Like when an Object is created; It goes to __init__ method; But what if I need to 
                modify the content of arguments, In this case I need to create another object; So, In this case; I can make the Object as callable say:
                a=A(1, 2, 3)                            #It goes to __init__() method and instantiate the object
                a(1,2,3)                                #I can't do if I havn't make the Object as callable

                For Example:
                        class A(object):
                            def __init__(self,a,b,c):
                                self.a=a
                                self.b=b
                                self.c=c
                            def __call__(self,a,b,c):
                                self.a=a
                                self.b=b
                                self.c=c
                                print "Hello; Talat Parwez"

               1. a=test.A(1,2,3)                         #Will Instantiate the object
               2. a(1,2,3)                                #Will go to the __call__() method as Now our Object is callable

                        Without __call__ method I couldn't be able to execute the 2nd line


<ACCESSING OBJECT ELEMENT>
    If there's an object and want to know the elements associated with this object the We can use,
        dir(obj)
        vars(obj)
        inpect.getmembers(obj)
        obj.__dict__
        from pprint import pprint 
        pprin(dir(obj)), pprint(vars(obj))

_______________________________________________________________________________________________________________________________________________________________
                
<MAGIC METHODS> :
    These are those methods which can be used as built-in methods and listed as follows:
        __eq__,__ne__, __gt__, __le__, __ge__, __pos__(self), __neg__(self), __abs__(self), __invert__(self) [NOT operator], __round__(self, n),
        __floor__(self), __ceil__(self), __trunc__(self), __add__(self, other), __sub__(self, other), __mul__(self, other), __floordiv(self, other), __div__(self,
other), __truediv__(self, other), __mod__(self, other), __divmod__(self, other), __pow__(self, other), __and__(self, other), __or__(sel, other), __xor__(self, other), __int__(self)
    
    Some magic methods are also available for representation of Class 
        __str__(self), __repr__(self), __unicode__(self), __format__(self), __hash__(self), __nonzero__(self), __dir__(self), __sizeof__(self)

	    __str__() defines behaviour when str() is called on the instance of the class
        __repr__() defines behaviour when str() is called on the instance of the class
                The difference between them is intended audience; __repr__() machine readable and __str__() is human readable
        __unicode__() same as __str__ but return a unicode string
        __hash__(self), dir(), __getattr__(self, name), __setattr__(self, name, value), __delattr__(self, name), __getattribute__()
        __len__(self), __getitem__(self, key), __setitem__(self, key, value), __delitem__(self, key), __iter__(self), __reversed__(self)
        __copy__(self)==shallow copy, __deepcopy__(self, dict)       
        
        For immutable objects, there's no need of for copying because the data will never change.Python uses the same data and Ids are always the same.
        For mutable objects; Since they can potentially change, Shallow copy creates a new object.
        For mutable objests; Since they can potentially change, Deep copy creates a new object for Main list as well as for the data containing inside in it.
                Suppose I have a list of lists, then deep copy created the object for nested lists also; So While working with mutable data objects, 
                Inner items will have the different ids as they are different objects. 
        If I change the data object, It will be reflected in copied data object in case of shallow copy
        If I change the data object, It will not be reflected in copied object in case of deep copy 
                       
                        class FunctionalTests(object):
                            def __init__(self, *values):
                                if values is None:
                                    self.values = []
                                    print "It recieved nothing ",self.values
                                else:
                                    self.values = values
                                    print "It recieved some values i.e.", self.values
                            
                            def __len__(self):
                                print "The total number of items recieved are: ", len(self.values)
                            
                            def __getitem__(self, key):
                                try:
                                    print "The item you're looking for is: ", self.values[key]
                                except IndexError, e:
                                    print "You've given Index more than the length of Sequence"
_______________________________________________________________________________________________________________________________________________________________

<MODULES> :
    import python_file_name [without extension]
    from python_file_name import fn1, fn2, fn3

    We can have many submodules inside a module. A directory, with a __init__.py can also be used as a module and all
    .py files inside it become submodules.
    
    If __init__.py file has __all__, and __init__.py contains the following;
    from module import fn1
    __all__ = [fn1]


    then only the methods listed in list[i.e. fn1] will be imported when I'll do 
    from mymodule import *

    
      

Pickle Module: We can store any plain python object in a file and can get back it later.

	l=[1,2,3,4]				#A list is defined
	f=open("ll",'wb')			#A file is opened in a write binary mode
	pickle.dump(l,f)			#It will store the "l" object to "f".
	f.close()				#Close the file	
	del l					#del the "l" object, now you won't be able to access l.
	f=open('ll','rb')			#again open the file but in read binary mode
	result=pickle.load(f)			#load the content whatever is stored in f, as you did stored the l to f so l will come to result
	print result				#[1,2,3,4]


Sys Module:Access to some variable used or maintained by Interpreter and to that function that interacts strongly with Interpreter.sys.argv contains all
		   command line interpreters.

	For Example:
		    This one is used to get the command line arguments and command line arguments are those arguments when we give at the run time as:
		    python "file_name" arg1, arg2, arg3, ...
                    __future__ is used to get the functionallity of those functions that are not already present in your python; So with the application of
                    __future__ we can import future functions
		
		    	from __future__ import print_function
			import sys
			print(sys.argv, len(sys.argv))


			Now from the command prompt give the argumenmts as:
				python "file_name" Hello
				python "file_name" Hello Talat Parwez
				python "file_name" Hello "Talat" Parwez
				python "file_name" "Hello" Talat "Parwez"

<OS>
        To perform all the operating system related utilities; we use OS module
        To check whether a particular path exists in System or not; We can use:
                os.path.exists('/stalat/Instances/LA/') --> True if exists


        __file__ will tell you the name of the file which is currently being executed.

        SQLite is included in Python, so you won’t need to install anything else to support your database.


_ —> last printed statement on interpreter
_ —> Ignore the values while Un-Packing, a, _, _, d = (1, 2, 3, 4)
_function_name() —> will make it private, and when calling via:

from <module_name> import *, 
All the methods and variables will not be imported which have _ as prefix, But they can be imported If called via <module_name>._<method_name>

def foo():
  print “hello”

def _foo1():
  print “Hi”

from <module_name> import * —> _foo1() won’t be accessible
import <module_name> —> <module_name>._foo1() will be accessible

class <ClassName>:
  def foo(self):
    print “foo”

  def _foo1(self):
    print “foo1”

  def __foo2(self):
    print “foo2”

from <module_name> import <class_name> —> foo()/_foo1() are accessible but __foo2() won’t be accessible even by importing it.

_______________________________________________________________________________________________________________________________________________________________

<PROPERTY>:
	
_______________________________________________________________________________________________________________________________________________________________

<COLLECTIONS>
	<COUNTER>
	from collections import Counter
	lst = [1,2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 'a', 'a', 'c', 'a', 'c', 'c', 'c', 'b']
	dd = Counter(lst)
	Counter({1: 5, 2: 6, 'a': 3, 'b': 1, 'c': 4})			# Applicable on strings as well
	dd.most_common() 						# Counter({1: 5, 2: 6, 'a': 3, 'b': 1, 'c': 4})

	<DEFAULT_DICT>
	from collections import defaultdict				# If values aren’t assigned to keys then, default value is set
	d = defaultdict(lambda: 0)
	d[‘one’]							# 0
	d[’two’]							# 0

	<ORDERED_DICTIONARY>
	Normal dictionary doesn’t retain the order but Ordered dictionary does.
	from collections import OrderedDict
	d = OrderedDict()
	d[1] = ‘a’
	d[2] = ‘b’
	d[3] = ‘c’
	d[4] = ‘d’

	for k, v in d.items():
            print k, v							# Here order is retained

	<NAMED_TUPLE>:
	from collections import named tuple
	Dog = namedtuple(‘Dog’, ‘age breed name’)
	sam = Dog(age=2, breed=‘lab’, name=‘samy’)
	sam.age, sam.breed, sam.name					# So here, we can call age as sam[0] and sam.age as well

_______________________________________________________________________________________________________________________________________________________________

<TIMEIT>:
	import timeit									# this will give the time taken in execution of any LOC
	timeit.timeit(‘ “-”.join(str(n) for n in range(10)) ’, number = 20)		# here 20 is the number of times this LOC will get executed

<REGULAR EXPRESSIONS>:
	There are two ways to accomplish pattern matching - 
	- Searching (search()): looking for a pattern match in any part of the string
	- Matching (match()): match a pattern to an entire string (find all words having first letter as alphanumeric, second as an integer)
	import re
	match = re.search(“Talat”, “Talat Parwez”)				# SRE match object If found else None
	match.start()								# 0
	match.end()								# 5
	re.findall(‘match’, “Here is a match, here is another match”)		# [‘match’, ‘match’]
	
	There are five ways to express repetition in pattern:
	* A pattern followed by meta character * is repeated zero or more times.
	* Replace the * with + and pattern must appear atleast once.
	* Using ? means the pattern zero or more times.
	* For a specific number of occurrences, use {m} after the pattern, where m is replaced with the number of times the pattern should repeat.
	* Use {m, n} where m is the minimum number of repetitions and n is the maximum. Leaving out n (m{, }) means the value appears at least m times, with no maximum.

	[
		’sd*’, 				# s followed by zero or more d’s
		‘sd+’, 				# s followed by one or more d’s
		‘sd?’, 				# s followed by zero or one d
		‘sd{3}’,			# s followed by three d’s
		‘sd{2,3}’,			# s followed by two to three d’s
	]

	[
		‘[sd]’,				# either s or d
		’s[sd]+’,			# s followed by one or more s or d
	],				
	

	[^]					# ^ is used for exclusion
	[
		[^!.?],				# check for matches that are not a !, ., ?.
	]

	[a-f]					# would return matches with any instance of letters between a and f
	[
		‘[a-z]+’,			# sequences of lower case letters
		‘[A-Z]+’,			# sequences of upper case letters
		‘[a-zA-Z]+’,			# sequences of lower or upper case letters
		‘[A-Z][a-z]+’,			# one upper case letter followed by lower case letters
	]

	Instead of putting [0-9], [A-Z], these special characters can be used to achieve the same.
	\d					# a digit
	\D 					# a non-digit
	\s					# whitespace
	\S					# non whitespace
	\w					# alphanumeric
	\W					# non-alphanumeric
	\b and \B 				# pertain to word boundary matches

	
	literal				Match literal string value 'literal'			foo
	re1|re2				Match regular expressions re1 or re2			foo|bar
	.				Match any character (except \n)				b.b
	^				Match start of string					^Dear
	$				Match end of string					/bin/*sh$
	*				Match 0 or more occurances of preceding regex		[A-Za-z0-9]*
	+				Match 1 or more occurances of preceding regex		[a-z]+\.com
	?				Match 0 or 1 occurances of preceding regex		goo?
	{N} 				Match N occurances of preceding regex			[0-9]{3}
	{M, N}				Match from M to N occurances of preceding regex		[0-9]{5, 9}
	[...]				Match any single character from character class		[aeiou]
	[..x-y..]			Match any single character in range from x to y		[0-9], [A-Za-z]
	[^...]				Don't match any character from character class,
					including any ranges, if present			[^aeiou], [^A-Za-z0-9]
	(*|+|?|{})?			apply 'non-greedy' versions of above occurance		.*?[a-z]
	(...)				Match enclosed regex and save as subgroup		([0-9]{3})?, f(oo|u)

	^From				# Any string that starts with From
	/bin/tcsh$			# Any string that ends with /bin/tcsh
	^Subject: hi$			# Any string consisting solely of the string Subject: hi

	Creating character classes ([])
		b[aeiu]t		# bat, bet, bit, but
		[cr][23][dp][o2]	# A string of four characters: first is c or r, then 2 or 3 etc. r3p2, r2d2, c3po [] returns only 1 charatcer from charatcer class.
		z.[0-9]			# "z" followed by any character then followed by single digit
		[r-u][env-y][us]	# "r", 's', 't' or 'u' followed by 'e', 'n', 'v', 'w', 'x' or 'y' followed by 'u' or 's'
		[^aeiou]		# A non-vowel charatcer
		[^\t\n]			# Not a TAB or \n

	Multiple Occurence/Repetition using Closure operators (*, +, ?, {})
		*			# Match 0 or more occurances of regex immediately to its left
		+			# Match 1 or more occurences of regex
		?			# Match exactly 0 or 1 occurences of regex
	
		[dn]ot?			# 'd' or 'n' followed by an 'o' and atmost one 't' after that - 'do', 'no', 'dot', 'not'
		0?[0-9]			# digit and then 0 or 1 or .. 9
		[0-9]{15-16}		# fifteen or sixteen digits
		</?[^>]+>		# string that match all valid/invalid HTML tags
		
		\w+-\d+			# alphanumeric string and number separated by hyphen
		\d{3}-\d{3}-\d{4}	# telephone numbers with area code prefix, 800-555-1212
		\w+@\w+\.com		# xxx@yyy.com
		
<SOCKET PROGRAMMING>:
    To create a socket, must use the socket.socket() function which has the general syntax as:
        socket(sockt_family, socket_type, protocol=0)			# socket family is either AF_UNIX(local) or AF_INET(internet)
									# socket_type is either SOCK_STREAM(TCP-connection oriented) or SOCK_DGRAM(UDP-connection less)
	
	tcpsoc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	udpsoc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

	SETTING UP TCP SERVER/CLIENT APPLICATION

		SERVER.py

			from socket import *
			from time import ctime

			HOST = ''					# '' so that it can use any available address
			PORT = 21567					# any port to which client will point
			BUFSIZE = 1024					# length of the data
			ADDR = (HOST, PORT)

			tcpSerSock = socket(AF_INET, SOCK_STREAM)	# a TCP connection object
			tcpSerSock.bind(ADDR)				# this TCP object should be bound to some address
			tcpSerSock.listen(5)				# maximum number of incoming connection requestsi, no listen() call will be there in connectionless architecture 	

			while True:
			    print "waiting for a connection..."
    			    tcpCliSock, addr = tcpSerSock.accept()	# original server socket is free to accept new client requests and new separate client socket is returned
    			    print "connected to...: ", addr

    			    while True:
        		        data = tcpCliSock.recv(BUFSIZE)
        		        if not data:
            		            break
        		        tcpCliSock.send("[%s] %s"% (ctime(), data))
    			    tcpCliSock.close()
			tcpSerSock.close()

		CLIENT.py

			from socket import *

			HOST = "localhost"				# IP on which the server is running 
			PORT = 21567					# it must be same as of the server
			BUFSIZ = 1024
			ADDR = (HOST, PORT)

			tcpCliSock = socket(AF_INET, SOCK_STREAM)
			tcpCliSock.connect(ADDR)

			while True:
    			data = raw_input("> ")
    			if not data:
        		    break;
    			tcpCliSock.send(data)
    			data = tcpCliSock.recv(BUFSIZ)
    			if not data:
        		    break
    			print data

			tcpCliSock.close()

		SETTING UP UDP CLIENT/SERVER APPLICATION
		    SERVER.PY	
			
			from socket import *
			from time import ctime

			HOST = ""
			PORT = 21567
			BUFFSIZE = 1024
			ADDR = (HOST, PORT)

			udpSerSoc = socket(AF_INET, SOCK_DGRAM)
			udpSerSoc.bind(ADDR)

			while True:
    			    print "waiting for a message..."
    			    data, addr = udpSerSoc.recvfrom(BUFFSIZE)
    			    udpSerSoc.sendto("[%s] %s" % (ctime(), data), addr)
    			    print "received from and returned to ...", addr

			udpSerSock.close()


		    CLIENT.PY

			from socket import *

			HOST = "localhost"
			PORT = 21567
			BUFFSIZE = 1024
			ADDR = (HOST, PORT)

			udpCliSock = socket(AF_INET, SOCK_DGRAM)

			while True:
    			    data = raw_input(">")
      			    if not data:
        			break;

    			    udpCliSock.sendto(data, ADDR)
    			    data, ADDR = udpCliSock.recvfrom(BUFFSIZE)
    			    if not data:
        			break;
    			    print data

			udpCliSock.close()


<MULTITHREADED PROGRAMMING>:
	We actually don't the functionality of mutli threading in python due to Global interpreter lock which ensures that only one thread is running. Execution of python code is controlled by Python virtual machine(Interpreter main loop). Python was designed in such a way that only one thread of control may be executing in this main loop. Many prorams can be in memory but only is live on the CPU at given moment. Access to Python virtual machine is is controlled by the GIL.
	We have two ways of implementing threading in python which are in implemented in 2 modules - 
		1. Thread (lower level threading) - Not recommended
		2. threadingv(higher level threading) - recommended

	With thread module, child thread exits without prompting/warning and without cleanup and cause main thread to exits and when main thread exits, all other thread die without cleanup.

	WITHOUT_THREADING.PY: (This will completely take 6 seconds to execute)
		from time import ctime, sleep

		def loop0():
		    print "starting loop0 at: ", ctime()
		    sleep(4)
		    print "loop 0 done at: ", ctime()

		def loop1():
		    print "starting loop1 at: ", ctime()
		    sleep(2)
		    print "loop 1 done at: ", ctime()

		if __name__ == "__main__":
		    loop0()
		    loop1()


	WITH_THREAD.PY: (This will take 4 seconds and some overhead)
		from time import ctime, sleep
		import thread

		def loop0(lock):
		    print "starting loop0 at: ", ctime()
		    sleep(4)
		    print "loop 0 done at: ", ctime()
		    lock.release()

		def loop1(lock):
		    print "starting loop1 at: ", ctime()
		    sleep(2)
		    print "loop 1 done at: ", ctime()
		    lock.release()

		if __name__ == "__main__":
		    lock0 = thread.allocate_lock()
		    lock1 = thread.allocate_lock()
		    lock0.acquire()
		    lock1.acquire()
		    print lock0, lock1
		    thread.start_new_thread(loop0, (lock0, ))
		    thread.start_new_thread(loop1, (lock1, ))
		    while lock0.locked():
		        pass
		    while lock1.locked():
		        pass

	DAEMON THREADS - A daemon is typically a server that waits for client requests to service. if we set daemon flag for a thread, we're basically saying that its not critical and it's okay for a process to exit without waiting for it to finish. If your main thread is ready to exit and you don't care to wait for the child the child to finish, then set their daemon flags. entire python program stay alive untill all non-daemonic threads have exited.

<QUESTIONS:>
* Print the length of each word in sentence using map and lambda
		map(lambda word: len(word), word.split())

* Take a list of digits and return the number that they correspond to. 
		reduce(lambda a, b: a*10 +b , [3,4,5,6,1])

* Use filter to filter out the words which starts from the target letter.
		[i for i in ['hello', 'are', 'cat', 'dog', 'ham'] if i.startswith('h')]

* Use zip and list comprehension to return list of same length where each value is the two strings from L1 and L2 concatenated together with connector between them
		['-'.join(word) for word in zip(['a', 'b'], ['A', 'B'])]

* Use enumerate and other skills to return a dictionary which has the values of the list as the keys and index as the value. You may assume that a value will only appear once in the given list
		[{val: idx} for idx, val in enumerate(lst)]

* Return the count of the number of items in the list whose value equals to its index
		[(idx, val) for idx, val in enumerate(lst) if len(val)==idx]

* Create a generator that generates the squares of numbers upto some number N:
	def gen_squares(N):
          for i in range(N):
              yield i**2

* Create a generator that yields “n” random numbers between a low and high number.
	def gen_random(min_num, max_num, N):
           for i in range(N):
               yield random.randint(min_num, max_num)
	
	ff = gen_random(10, 20, 8)
	for i in ff:
	    print i
